{"version":3,"sources":["../../../src/fields/config/sanitize.ts"],"sourcesContent":["// @ts-strict-ignore\nimport { deepMergeSimple } from '@payloadcms/translations/utilities'\nimport { v4 as uuid } from 'uuid'\n\nimport type {\n  CollectionConfig,\n  SanitizedJoin,\n  SanitizedJoins,\n} from '../../collections/config/types.js'\nimport type { Config, SanitizedConfig } from '../../config/types.js'\nimport type { Field } from './types.js'\n\nimport {\n  DuplicateFieldName,\n  InvalidFieldName,\n  InvalidFieldRelationship,\n  MissingEditorProp,\n  MissingFieldType,\n} from '../../errors/index.js'\nimport { formatLabels, toWords } from '../../utilities/formatLabels.js'\nimport { baseBlockFields } from '../baseFields/baseBlockFields.js'\nimport { baseIDField } from '../baseFields/baseIDField.js'\nimport { baseTimezoneField } from '../baseFields/timezone/baseField.js'\nimport { defaultTimezones } from '../baseFields/timezone/defaultTimezones.js'\nimport { setDefaultBeforeDuplicate } from '../setDefaultBeforeDuplicate.js'\nimport { validations } from '../validations.js'\nimport { sanitizeJoinField } from './sanitizeJoinField.js'\nimport { fieldAffectsData, fieldIsLocalized, tabHasName } from './types.js'\n\ntype Args = {\n  collectionConfig?: CollectionConfig\n  config: Config\n  existingFieldNames?: Set<string>\n  fields: Field[]\n  joinPath?: string\n  /**\n   * When not passed in, assume that join are not supported (globals, arrays, blocks)\n   */\n  joins?: SanitizedJoins\n  parentIsLocalized: boolean\n  polymorphicJoins?: SanitizedJoin[]\n\n  /**\n   * If true, a richText field will require an editor property to be set, as the sanitizeFields function will not add it from the payload config if not present.\n   *\n   * @default false\n   */\n  requireFieldLevelRichTextEditor?: boolean\n  /**\n   * If this property is set, RichText fields won't be sanitized immediately. Instead, they will be added to this array as promises\n   * so that you can sanitize them together, after the config has been sanitized.\n   */\n  richTextSanitizationPromises?: Array<(config: SanitizedConfig) => Promise<void>>\n  /**\n   * If not null, will validate that upload and relationship fields do not relate to a collection that is not in this array.\n   * This validation will be skipped if validRelationships is null.\n   */\n  validRelationships: null | string[]\n}\n\nexport const sanitizeFields = async ({\n  config,\n  existingFieldNames = new Set(),\n  fields,\n  joinPath = '',\n  joins,\n  parentIsLocalized,\n  polymorphicJoins,\n  requireFieldLevelRichTextEditor = false,\n  richTextSanitizationPromises,\n  validRelationships,\n}: Args): Promise<Field[]> => {\n  if (!fields) {\n    return []\n  }\n\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i]\n\n    if ('_sanitized' in field && field._sanitized === true) {\n      continue\n    }\n    if ('_sanitized' in field) {\n      field._sanitized = true\n    }\n\n    if (!field.type) {\n      throw new MissingFieldType(field)\n    }\n\n    // assert that field names do not contain forbidden characters\n    if (fieldAffectsData(field) && field.name.includes('.')) {\n      throw new InvalidFieldName(field, field.name)\n    }\n\n    // Auto-label\n    if (\n      'name' in field &&\n      field.name &&\n      typeof field.label !== 'object' &&\n      typeof field.label !== 'string' &&\n      typeof field.label !== 'function' &&\n      field.label !== false\n    ) {\n      field.label = toWords(field.name)\n    }\n\n    if (\n      field.type === 'checkbox' &&\n      typeof field.defaultValue === 'undefined' &&\n      field.required === true\n    ) {\n      field.defaultValue = false\n    }\n\n    if (field.type === 'join') {\n      sanitizeJoinField({ config, field, joinPath, joins, parentIsLocalized, polymorphicJoins })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (validRelationships) {\n        const relationships = Array.isArray(field.relationTo)\n          ? field.relationTo\n          : [field.relationTo]\n        relationships.forEach((relationship: string) => {\n          if (!validRelationships.includes(relationship)) {\n            throw new InvalidFieldRelationship(field, relationship)\n          }\n        })\n      }\n\n      if (field.min && !field.minRows) {\n        console.warn(\n          `(payload): The \"min\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"minRows\" instead.`,\n        )\n        field.minRows = field.min\n      }\n      if (field.max && !field.maxRows) {\n        console.warn(\n          `(payload): The \"max\" property is deprecated for the Relationship field \"${field.name}\" and will be removed in a future version. Please use \"maxRows\" instead.`,\n        )\n        field.maxRows = field.max\n      }\n    }\n\n    if (field.type === 'upload') {\n      if (!field.admin || !('isSortable' in field.admin)) {\n        field.admin = {\n          isSortable: true,\n          ...field.admin,\n        }\n      }\n    }\n\n    if (field.type === 'array' && field.fields) {\n      field.fields.push(baseIDField)\n    }\n\n    if ((field.type === 'blocks' || field.type === 'array') && field.label) {\n      field.labels = field.labels || formatLabels(field.name)\n    }\n\n    if (fieldAffectsData(field)) {\n      if (existingFieldNames.has(field.name)) {\n        throw new DuplicateFieldName(field.name)\n      } else if (!['blockName', 'id'].includes(field.name)) {\n        existingFieldNames.add(field.name)\n      }\n\n      if (typeof field.localized !== 'undefined') {\n        let shouldDisableLocalized = !config.localization\n\n        if (\n          process.env.NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized !== 'true' &&\n          parentIsLocalized &&\n          // @todo PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY=true will be the default in 4.0\n          process.env.PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY !== 'true'\n        ) {\n          shouldDisableLocalized = true\n        }\n\n        if (shouldDisableLocalized) {\n          delete field.localized\n        }\n      }\n\n      if (typeof field.validate === 'undefined') {\n        const defaultValidate = validations[field.type]\n        if (defaultValidate) {\n          field.validate = (val, options) => defaultValidate(val, { ...field, ...options })\n        } else {\n          field.validate = (): true => true\n        }\n      }\n\n      if (!field.hooks) {\n        field.hooks = {}\n      }\n      if (!field.access) {\n        field.access = {}\n      }\n\n      setDefaultBeforeDuplicate(field, parentIsLocalized)\n    }\n\n    if (!field.admin) {\n      field.admin = {}\n    }\n\n    // Make sure that the richText field has an editor\n    if (field.type === 'richText') {\n      const sanitizeRichText = async (_config: SanitizedConfig) => {\n        if (!field.editor) {\n          if (_config.editor && !requireFieldLevelRichTextEditor) {\n            // config.editor should be sanitized at this point\n            field.editor = _config.editor\n          } else {\n            throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n          }\n        }\n\n        if (typeof field.editor === 'function') {\n          field.editor = await field.editor({\n            config: _config,\n            isRoot: requireFieldLevelRichTextEditor,\n            parentIsLocalized: parentIsLocalized || field.localized,\n          })\n        }\n\n        if (field.editor.i18n && Object.keys(field.editor.i18n).length >= 0) {\n          config.i18n.translations = deepMergeSimple(config.i18n.translations, field.editor.i18n)\n        }\n      }\n      if (richTextSanitizationPromises) {\n        richTextSanitizationPromises.push(sanitizeRichText)\n      } else {\n        await sanitizeRichText(config as unknown as SanitizedConfig)\n      }\n    }\n\n    if (field.type === 'blocks' && field.blocks) {\n      if (field.blockReferences && field.blocks?.length) {\n        throw new Error('You cannot have both blockReferences and blocks in the same blocks field')\n      }\n\n      for (const block of field.blockReferences ?? field.blocks) {\n        if (typeof block === 'string') {\n          continue\n        }\n        if (block._sanitized === true) {\n          continue\n        }\n        block._sanitized = true\n        block.fields = block.fields.concat(baseBlockFields)\n        block.labels = !block.labels ? formatLabels(block.slug) : block.labels\n        block.fields = await sanitizeFields({\n          config,\n          existingFieldNames: new Set(),\n          fields: block.fields,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n      }\n    }\n\n    if ('fields' in field && field.fields) {\n      field.fields = await sanitizeFields({\n        config,\n        existingFieldNames: fieldAffectsData(field) ? new Set() : existingFieldNames,\n        fields: field.fields,\n        joinPath: fieldAffectsData(field)\n          ? `${joinPath ? joinPath + '.' : ''}${field.name}`\n          : joinPath,\n        joins,\n        parentIsLocalized: parentIsLocalized || fieldIsLocalized(field),\n        polymorphicJoins,\n        requireFieldLevelRichTextEditor,\n        richTextSanitizationPromises,\n        validRelationships,\n      })\n    }\n\n    if (field.type === 'tabs') {\n      for (let j = 0; j < field.tabs.length; j++) {\n        const tab = field.tabs[j]\n        if (tabHasName(tab) && typeof tab.label === 'undefined') {\n          tab.label = toWords(tab.name)\n        }\n\n        if (\n          'admin' in tab &&\n          tab.admin?.condition &&\n          typeof tab.admin.condition === 'function' &&\n          !tab.id\n        ) {\n          // Always attach a UUID to tabs with a condition so there's no conflicts even if there are duplicate nested names\n          tab.id = tabHasName(tab) ? `${tab.name}_${uuid()}` : uuid()\n        }\n\n        tab.fields = await sanitizeFields({\n          config,\n          existingFieldNames: tabHasName(tab) ? new Set() : existingFieldNames,\n          fields: tab.fields,\n          joinPath: tabHasName(tab) ? `${joinPath ? joinPath + '.' : ''}${tab.name}` : joinPath,\n          joins,\n          parentIsLocalized: parentIsLocalized || (tabHasName(tab) && tab.localized),\n          polymorphicJoins,\n          requireFieldLevelRichTextEditor,\n          richTextSanitizationPromises,\n          validRelationships,\n        })\n        field.tabs[j] = tab\n      }\n    }\n\n    if (field.type === 'ui' && typeof field.admin.disableBulkEdit === 'undefined') {\n      field.admin.disableBulkEdit = true\n    }\n\n    fields[i] = field\n\n    // Insert our field after assignment\n    if (field.type === 'date' && field.timezone) {\n      const name = field.name + '_tz'\n      const defaultTimezone = config.admin.timezones.defaultTimezone\n\n      const supportedTimezones = config.admin.timezones.supportedTimezones\n\n      const options =\n        typeof supportedTimezones === 'function'\n          ? supportedTimezones({ defaultTimezones })\n          : supportedTimezones\n\n      // Need to set the options here manually so that any database enums are generated correctly\n      // The UI component will import the options from the config\n      const timezoneField = baseTimezoneField({\n        name,\n        defaultValue: defaultTimezone,\n        options,\n        required: field.required,\n      })\n\n      fields.splice(++i, 0, timezoneField)\n    }\n  }\n\n  return fields\n}\n"],"names":["deepMergeSimple","v4","uuid","DuplicateFieldName","InvalidFieldName","InvalidFieldRelationship","MissingEditorProp","MissingFieldType","formatLabels","toWords","baseBlockFields","baseIDField","baseTimezoneField","defaultTimezones","setDefaultBeforeDuplicate","validations","sanitizeJoinField","fieldAffectsData","fieldIsLocalized","tabHasName","sanitizeFields","config","existingFieldNames","Set","fields","joinPath","joins","parentIsLocalized","polymorphicJoins","requireFieldLevelRichTextEditor","richTextSanitizationPromises","validRelationships","i","length","field","_sanitized","type","name","includes","label","defaultValue","required","relationships","Array","isArray","relationTo","forEach","relationship","min","minRows","console","warn","max","maxRows","admin","isSortable","push","labels","has","add","localized","shouldDisableLocalized","localization","process","env","NEXT_PUBLIC_PAYLOAD_COMPATIBILITY_allowLocalizedWithinLocalized","PAYLOAD_DO_NOT_SANITIZE_LOCALIZED_PROPERTY","validate","defaultValidate","val","options","hooks","access","sanitizeRichText","_config","editor","isRoot","i18n","Object","keys","translations","blocks","blockReferences","Error","block","concat","slug","j","tabs","tab","condition","id","disableBulkEdit","timezone","defaultTimezone","timezones","supportedTimezones","timezoneField","splice"],"mappings":"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"}