{"version":3,"sources":["../../../../src/fields/hooks/beforeChange/promise.ts"],"sourcesContent":["// @ts-strict-ignore\nimport type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { ValidationFieldError } from '../../../errors/index.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type { RequestContext } from '../../../index.js'\nimport type { JsonObject, Operation, PayloadRequest } from '../../../types/index.js'\nimport type { Block, Field, TabAsField, Validate } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { deepMergeWithSourceArrays } from '../../../utilities/deepMerge.js'\nimport { getTranslatedLabel } from '../../../utilities/getTranslatedLabel.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { getExistingRowDoc } from './getExistingRowDoc.js'\nimport { traverseFields } from './traverseFields.js'\n\nfunction buildFieldLabel(parentLabel: string, label: string): string {\n  const capitalizedLabel = label.charAt(0).toUpperCase() + label.slice(1)\n  return parentLabel && capitalizedLabel\n    ? `${parentLabel} > ${capitalizedLabel}`\n    : capitalizedLabel || parentLabel\n}\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  data: JsonObject\n  doc: JsonObject\n  docWithLocales: JsonObject\n  errors: ValidationFieldError[]\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * Built up labels of parent fields\n   *\n   * @example \"Group Field > Tab Field > Text Field\"\n   */\n  fieldLabelPath: string\n  global: null | SanitizedGlobalConfig\n  id?: number | string\n  mergeLocaleActions: (() => Promise<void> | void)[]\n  operation: Operation\n  parentIndexPath: string\n  parentIsLocalized: boolean\n  parentPath: string\n  parentSchemaPath: string\n  req: PayloadRequest\n  siblingData: JsonObject\n  siblingDoc: JsonObject\n  siblingDocWithLocales?: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  skipValidation: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Run condition\n// - Execute field hooks\n// - Validate data\n// - Transform data for storage\n// - beforeDuplicate hooks (if duplicate)\n// - Unflatten locales\n\nexport const promise = async ({\n  id,\n  blockData,\n  collection,\n  context,\n  data,\n  doc,\n  docWithLocales,\n  errors,\n  field,\n  fieldIndex,\n  fieldLabelPath,\n  global,\n  mergeLocaleActions,\n  operation,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  req,\n  siblingData,\n  siblingDoc,\n  siblingDocWithLocales,\n  siblingFields,\n  skipValidation,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const { localization } = req.payload.config\n  const defaultLocale = localization ? localization?.defaultLocale : 'en'\n  const operationLocale = req.locale || defaultLocale\n\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n\n  const passesCondition = field.admin?.condition\n    ? Boolean(\n        field.admin.condition(data, siblingData, { blockData, path: pathSegments, user: req.user }),\n      )\n    : true\n  let skipValidationFromHere = skipValidation || !passesCondition\n\n  if (fieldAffectsData(field)) {\n    // skip validation if the field is localized and the incoming data is null\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && operationLocale !== defaultLocale) {\n      if (['array', 'blocks'].includes(field.type) && siblingData[field.name] === null) {\n        skipValidationFromHere = true\n      }\n    }\n\n    // Execute hooks\n    if (field.hooks?.beforeChange) {\n      for (const hook of field.hooks.beforeChange) {\n        const hookedValue = await hook({\n          blockData,\n          collection,\n          context,\n          data,\n          field,\n          global,\n          indexPath: indexPathSegments,\n          operation,\n          originalDoc: doc,\n          path: pathSegments,\n          previousSiblingDoc: siblingDoc,\n          previousValue: siblingDoc[field.name],\n          req,\n          schemaPath: schemaPathSegments,\n          siblingData,\n          siblingDocWithLocales,\n          siblingFields,\n          value: siblingData[field.name],\n        })\n\n        if (hookedValue !== undefined) {\n          siblingData[field.name] = hookedValue\n        }\n      }\n    }\n\n    // Validate\n    if (!skipValidationFromHere && 'validate' in field && field.validate) {\n      const valueToValidate = siblingData[field.name]\n      let jsonError: object\n\n      if (field.type === 'json' && typeof siblingData[field.name] === 'string') {\n        try {\n          JSON.parse(siblingData[field.name] as string)\n        } catch (e) {\n          jsonError = e\n        }\n      }\n\n      const validateFn: Validate<object, object, object, object> = field.validate as Validate<\n        object,\n        object,\n        object,\n        object\n      >\n      const validationResult = await validateFn(valueToValidate as never, {\n        ...field,\n        id,\n        blockData,\n        collectionSlug: collection?.slug,\n        data: deepMergeWithSourceArrays(doc, data),\n        event: 'submit',\n        // @ts-expect-error\n        jsonError,\n        operation,\n        path: pathSegments,\n        preferences: { fields: {} },\n        previousValue: siblingDoc[field.name],\n        req,\n        siblingData: deepMergeWithSourceArrays(siblingDoc, siblingData),\n      })\n\n      if (typeof validationResult === 'string') {\n        const fieldLabel = buildFieldLabel(\n          fieldLabelPath,\n          getTranslatedLabel(field?.label || field?.name, req.i18n),\n        )\n\n        errors.push({\n          label: fieldLabel,\n          message: validationResult,\n          path,\n        })\n      }\n    }\n\n    // Push merge locale action if applicable\n    if (localization && fieldShouldBeLocalized({ field, parentIsLocalized })) {\n      mergeLocaleActions.push(() => {\n        const localeData = {}\n\n        for (const locale of localization.localeCodes) {\n          const fieldValue =\n            locale === req.locale\n              ? siblingData[field.name]\n              : siblingDocWithLocales?.[field.name]?.[locale]\n\n          // update locale value if it's not undefined\n          if (typeof fieldValue !== 'undefined') {\n            localeData[locale] = fieldValue\n          }\n        }\n\n        // If there are locales with data, set the data\n        if (Object.keys(localeData).length > 0) {\n          siblingData[field.name] = localeData\n        }\n      })\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingData[field.name]\n\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          promises.push(\n            traverseFields({\n              id,\n              blockData,\n              collection,\n              context,\n              data,\n              doc,\n              docWithLocales,\n              errors,\n              fieldLabelPath:\n                field?.label === false\n                  ? fieldLabelPath\n                  : buildFieldLabel(\n                      fieldLabelPath,\n                      `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,\n                    ),\n              fields: field.fields,\n              global,\n              mergeLocaleActions,\n              operation,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath,\n              req,\n              siblingData: row as JsonObject,\n              siblingDoc: getExistingRowDoc(row as JsonObject, siblingDoc[field.name]),\n              siblingDocWithLocales: getExistingRowDoc(\n                row as JsonObject,\n                siblingDocWithLocales[field.name],\n              ),\n              skipValidation: skipValidationFromHere,\n            }),\n          )\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingData[field.name]\n      if (Array.isArray(rows)) {\n        const promises = []\n\n        rows.forEach((row, rowIndex) => {\n          const rowSiblingDoc = getExistingRowDoc(row as JsonObject, siblingDoc[field.name])\n\n          const rowSiblingDocWithLocales = getExistingRowDoc(\n            row as JsonObject,\n            siblingDocWithLocales ? siblingDocWithLocales[field.name] : {},\n          )\n\n          const blockTypeToMatch = (row as JsonObject).blockType || rowSiblingDoc.blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          if (block) {\n            promises.push(\n              traverseFields({\n                id,\n                blockData: row,\n                collection,\n                context,\n                data,\n                doc,\n                docWithLocales,\n                errors,\n                fieldLabelPath:\n                  field?.label === false\n                    ? fieldLabelPath\n                    : buildFieldLabel(\n                        fieldLabelPath,\n                        `${getTranslatedLabel(field?.label || field?.name, req.i18n)} ${rowIndex + 1}`,\n                      ),\n                fields: block.fields,\n                global,\n                mergeLocaleActions,\n                operation,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath + '.' + block.slug,\n                req,\n                siblingData: row as JsonObject,\n                siblingDoc: rowSiblingDoc,\n                siblingDocWithLocales: rowSiblingDocWithLocales,\n                skipValidation: skipValidationFromHere,\n              }),\n            )\n          }\n        })\n\n        await Promise.all(promises)\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field.type === 'row' || field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.type, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (typeof siblingData[field.name] !== 'object') {\n        siblingData[field.name] = {}\n      }\n\n      if (typeof siblingDoc[field.name] !== 'object') {\n        siblingDoc[field.name] = {}\n      }\n\n      if (typeof siblingDocWithLocales[field.name] !== 'object') {\n        siblingDocWithLocales[field.name] = {}\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.name, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: '',\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: siblingData[field.name] as JsonObject,\n        siblingDoc: siblingDoc[field.name] as JsonObject,\n        siblingDocWithLocales: siblingDocWithLocales[field.name] as JsonObject,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'point': {\n      // Transform point data for storage\n      if (\n        Array.isArray(siblingData[field.name]) &&\n        siblingData[field.name][0] !== null &&\n        siblingData[field.name][1] !== null\n      ) {\n        siblingData[field.name] = {\n          type: 'Point',\n          coordinates: [\n            parseFloat(siblingData[field.name][0]),\n            parseFloat(siblingData[field.name][1]),\n          ],\n        }\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.beforeChange?.length) {\n        for (const hook of editor.hooks.beforeChange) {\n          const hookedValue = await hook({\n            collection,\n            context,\n            data,\n            docWithLocales,\n            errors,\n            field,\n            fieldLabelPath:\n              field?.label === false\n                ? fieldLabelPath\n                : buildFieldLabel(\n                    fieldLabelPath,\n                    getTranslatedLabel(field?.label || field?.name, req.i18n),\n                  ),\n            global,\n            indexPath: indexPathSegments,\n            mergeLocaleActions,\n            operation,\n            originalDoc: doc,\n            parentIsLocalized,\n            path: pathSegments,\n            previousSiblingDoc: siblingDoc,\n            previousValue: siblingDoc[field.name],\n            req,\n            schemaPath: schemaPathSegments,\n            siblingData,\n            siblingDocWithLocales,\n            skipValidation,\n            value: siblingData[field.name],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingData[field.name] = hookedValue\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'tab': {\n      let tabSiblingData = siblingData\n      let tabSiblingDoc = siblingDoc\n      let tabSiblingDocWithLocales = siblingDocWithLocales\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        if (typeof siblingData[field.name] !== 'object') {\n          siblingData[field.name] = {}\n        }\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          siblingDoc[field.name] = {}\n        }\n\n        if (typeof siblingDocWithLocales[field.name] !== 'object') {\n          siblingDocWithLocales[field.name] = {}\n        }\n\n        tabSiblingData = siblingData[field.name] as JsonObject\n        tabSiblingDoc = siblingDoc[field.name] as JsonObject\n        tabSiblingDocWithLocales = siblingDocWithLocales[field.name] as JsonObject\n      }\n\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(\n                fieldLabelPath,\n                getTranslatedLabel(field?.label || field?.name, req.i18n),\n              ),\n        fields: field.fields,\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData: tabSiblingData,\n        siblingDoc: tabSiblingDoc,\n        siblingDocWithLocales: tabSiblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      await traverseFields({\n        id,\n        blockData,\n        collection,\n        context,\n        data,\n        doc,\n        docWithLocales,\n        errors,\n        fieldLabelPath:\n          field?.label === false\n            ? fieldLabelPath\n            : buildFieldLabel(fieldLabelPath, getTranslatedLabel(field?.label || '', req.i18n)),\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        global,\n        mergeLocaleActions,\n        operation,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        req,\n        siblingData,\n        siblingDoc,\n        siblingDocWithLocales,\n        skipValidation: skipValidationFromHere,\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","deepMergeWithSourceArrays","getTranslatedLabel","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getFieldPathsModified","getFieldPaths","getExistingRowDoc","traverseFields","buildFieldLabel","parentLabel","label","capitalizedLabel","charAt","toUpperCase","slice","promise","id","blockData","collection","context","data","doc","docWithLocales","errors","field","fieldIndex","fieldLabelPath","global","mergeLocaleActions","operation","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","req","siblingData","siblingDoc","siblingDocWithLocales","siblingFields","skipValidation","indexPath","path","schemaPath","index","localization","payload","config","defaultLocale","operationLocale","locale","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","passesCondition","admin","condition","user","skipValidationFromHere","includes","type","name","hooks","beforeChange","hook","hookedValue","originalDoc","previousSiblingDoc","previousValue","value","undefined","validate","valueToValidate","jsonError","JSON","parse","e","validateFn","validationResult","collectionSlug","slug","event","preferences","fields","fieldLabel","i18n","push","message","localeData","localeCodes","fieldValue","Object","keys","length","rows","Array","isArray","promises","forEach","row","rowIndex","localized","Promise","all","rowSiblingDoc","rowSiblingDocWithLocales","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","coordinates","parseFloat","editor","Error","tabSiblingData","tabSiblingDoc","tabSiblingDocWithLocales","isNamedTab","tabs","tab"],"mappings":"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"}