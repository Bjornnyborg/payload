{"version":3,"sources":["../src/traverseFields.ts"],"sourcesContent":["import type { DocumentEvent, FieldSchemaJSON } from 'payload'\n\nimport type { PopulationsByCollection } from './types.js'\n\nimport { traverseRichText } from './traverseRichText.js'\n\nexport const traverseFields = <T extends Record<string, any>>(args: {\n  externallyUpdatedRelationship?: DocumentEvent\n  fieldSchema: FieldSchemaJSON\n  incomingData: T\n  localeChanged: boolean\n  populationsByCollection: PopulationsByCollection\n  result: Record<string, any>\n}): void => {\n  const {\n    externallyUpdatedRelationship,\n    fieldSchema: fieldSchemas,\n    incomingData,\n    localeChanged,\n    populationsByCollection,\n    result,\n  } = args\n\n  fieldSchemas.forEach((fieldSchema) => {\n    if ('name' in fieldSchema && typeof fieldSchema.name === 'string') {\n      const fieldName = fieldSchema.name\n\n      switch (fieldSchema.type) {\n        case 'array':\n          if (\n            !incomingData[fieldName] &&\n            incomingData[fieldName] !== undefined &&\n            result?.[fieldName] !== undefined\n          ) {\n            result[fieldName] = []\n          }\n\n          if (Array.isArray(incomingData[fieldName])) {\n            result[fieldName] = incomingData[fieldName].map((incomingRow, i) => {\n              if (!result[fieldName]) {\n                result[fieldName] = []\n              }\n\n              if (!result[fieldName][i]) {\n                result[fieldName][i] = {}\n              }\n\n              traverseFields({\n                externallyUpdatedRelationship,\n                fieldSchema: fieldSchema.fields!,\n                incomingData: incomingRow,\n                localeChanged,\n                populationsByCollection,\n                result: result[fieldName][i],\n              })\n\n              return result[fieldName][i]\n            })\n          }\n\n          break\n\n        case 'blocks':\n          if (Array.isArray(incomingData[fieldName])) {\n            result[fieldName] = incomingData[fieldName].map((incomingBlock, i) => {\n              const incomingBlockJSON = fieldSchema.blocks?.[incomingBlock.blockType]\n\n              if (!result[fieldName]) {\n                result[fieldName] = []\n              }\n\n              if (\n                !result[fieldName][i] ||\n                result[fieldName][i].id !== incomingBlock.id ||\n                result[fieldName][i].blockType !== incomingBlock.blockType\n              ) {\n                result[fieldName][i] = {\n                  blockType: incomingBlock.blockType,\n                }\n              }\n\n              traverseFields({\n                externallyUpdatedRelationship,\n                fieldSchema: incomingBlockJSON!.fields!,\n                incomingData: incomingBlock,\n                localeChanged,\n                populationsByCollection,\n                result: result[fieldName][i],\n              })\n\n              return result[fieldName][i]\n            })\n          } else {\n            result[fieldName] = []\n          }\n\n          break\n\n        case 'group':\n        // falls through\n        case 'tabs':\n          if (!result[fieldName]) {\n            result[fieldName] = {}\n          }\n\n          traverseFields({\n            externallyUpdatedRelationship,\n            fieldSchema: fieldSchema.fields!,\n            incomingData: incomingData[fieldName] || {},\n            localeChanged,\n            populationsByCollection,\n            result: result[fieldName],\n          })\n\n          break\n\n        case 'relationship':\n        // falls through\n        case 'upload':\n          // Handle `hasMany` relationships\n          if (fieldSchema.hasMany && Array.isArray(incomingData[fieldName])) {\n            if (!result[fieldName] || !incomingData[fieldName].length) {\n              result[fieldName] = []\n            }\n\n            incomingData[fieldName].forEach((incomingRelation, i) => {\n              // Handle `hasMany` polymorphic\n              if (Array.isArray(fieldSchema.relationTo)) {\n                // if the field doesn't exist on the result, create it\n                // the value will be populated later\n                if (!result[fieldName][i]) {\n                  result[fieldName][i] = {\n                    relationTo: incomingRelation.relationTo,\n                  }\n                }\n\n                const oldID = result[fieldName][i]?.value?.id\n                const oldRelation = result[fieldName][i]?.relationTo\n                const newID = incomingRelation.value\n                const newRelation = incomingRelation.relationTo\n\n                const hasChanged = newID !== oldID || newRelation !== oldRelation\n\n                const hasUpdated =\n                  newRelation === externallyUpdatedRelationship?.entitySlug &&\n                  newID === externallyUpdatedRelationship?.id\n\n                if (hasChanged || hasUpdated || localeChanged) {\n                  if (!populationsByCollection[newRelation]) {\n                    populationsByCollection[newRelation] = []\n                  }\n\n                  populationsByCollection[newRelation].push({\n                    id: incomingRelation.value,\n                    accessor: 'value',\n                    ref: result[fieldName][i],\n                  })\n                }\n              } else {\n                // Handle `hasMany` monomorphic\n                const hasChanged = incomingRelation !== result[fieldName][i]?.id\n\n                const hasUpdated =\n                  fieldSchema.relationTo === externallyUpdatedRelationship?.entitySlug &&\n                  incomingRelation === externallyUpdatedRelationship?.id\n\n                if (hasChanged || hasUpdated || localeChanged) {\n                  if (!populationsByCollection[fieldSchema.relationTo!]) {\n                    populationsByCollection[fieldSchema.relationTo!] = []\n                  }\n\n                  populationsByCollection[fieldSchema.relationTo!]?.push({\n                    id: incomingRelation,\n                    accessor: i,\n                    ref: result[fieldName],\n                  })\n                }\n              }\n            })\n          } else {\n            // Handle `hasOne` polymorphic\n            if (Array.isArray(fieldSchema.relationTo)) {\n              // if the field doesn't exist on the result, create it\n              // the value will be populated later\n              if (!result[fieldName]) {\n                result[fieldName] = {\n                  relationTo: incomingData[fieldName]?.relationTo,\n                }\n              }\n\n              const hasNewValue =\n                incomingData[fieldName] &&\n                typeof incomingData[fieldName] === 'object' &&\n                incomingData[fieldName] !== null\n\n              const hasOldValue =\n                result[fieldName] &&\n                typeof result[fieldName] === 'object' &&\n                result[fieldName] !== null\n\n              const newID = hasNewValue\n                ? typeof incomingData[fieldName].value === 'object'\n                  ? incomingData[fieldName].value.id\n                  : incomingData[fieldName].value\n                : ''\n\n              const oldID = hasOldValue\n                ? typeof result[fieldName].value === 'object'\n                  ? result[fieldName].value.id\n                  : result[fieldName].value\n                : ''\n\n              const newRelation = hasNewValue ? incomingData[fieldName].relationTo : ''\n              const oldRelation = hasOldValue ? result[fieldName].relationTo : ''\n\n              const hasChanged = newID !== oldID || newRelation !== oldRelation\n\n              const hasUpdated =\n                newRelation === externallyUpdatedRelationship?.entitySlug &&\n                newID === externallyUpdatedRelationship?.id\n\n              // if the new value/relation is different from the old value/relation\n              // populate the new value, otherwise leave it alone\n              if (hasChanged || hasUpdated || localeChanged) {\n                // if the new value is not empty, populate it\n                // otherwise set the value to null\n                if (newID) {\n                  if (!populationsByCollection[newRelation]) {\n                    populationsByCollection[newRelation] = []\n                  }\n\n                  populationsByCollection[newRelation].push({\n                    id: newID,\n                    accessor: 'value',\n                    ref: result[fieldName],\n                  })\n                } else {\n                  result[fieldName] = null\n                }\n              }\n            } else {\n              // Handle `hasOne` monomorphic\n              const newID: number | string | undefined =\n                (incomingData[fieldName] &&\n                  typeof incomingData[fieldName] === 'object' &&\n                  incomingData[fieldName].id) ||\n                incomingData[fieldName]\n\n              const oldID: number | string | undefined =\n                (result[fieldName] &&\n                  typeof result[fieldName] === 'object' &&\n                  result[fieldName].id) ||\n                result[fieldName]\n\n              const hasChanged = newID !== oldID\n\n              const hasUpdated =\n                fieldSchema.relationTo === externallyUpdatedRelationship?.entitySlug &&\n                newID === externallyUpdatedRelationship?.id\n\n              // if the new value is different from the old value\n              // populate the new value, otherwise leave it alone\n              if (hasChanged || hasUpdated || localeChanged) {\n                // if the new value is not empty, populate it\n                // otherwise set the value to null\n                if (newID) {\n                  if (!populationsByCollection[fieldSchema.relationTo!]) {\n                    populationsByCollection[fieldSchema.relationTo!] = []\n                  }\n\n                  populationsByCollection[fieldSchema.relationTo!]?.push({\n                    id: newID,\n                    accessor: fieldName,\n                    ref: result as Record<string, unknown>,\n                  })\n                } else {\n                  result[fieldName] = null\n                }\n              }\n            }\n          }\n\n          break\n        case 'richText':\n          result[fieldName] = traverseRichText({\n            externallyUpdatedRelationship,\n            incomingData: incomingData[fieldName],\n            populationsByCollection,\n            result: result[fieldName],\n          })\n\n          break\n\n        default:\n          result[fieldName] = incomingData[fieldName]\n      }\n    }\n  })\n}\n"],"names":["traverseRichText","traverseFields","args","externallyUpdatedRelationship","fieldSchema","fieldSchemas","incomingData","localeChanged","populationsByCollection","result","forEach","name","fieldName","type","undefined","Array","isArray","map","incomingRow","i","fields","incomingBlock","incomingBlockJSON","blocks","blockType","id","hasMany","length","incomingRelation","relationTo","oldID","value","oldRelation","newID","newRelation","hasChanged","hasUpdated","entitySlug","push","accessor","ref","hasNewValue","hasOldValue"],"mappings":"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"}