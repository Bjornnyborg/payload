{"version":3,"sources":["../../../src/field/elements/toggleList.tsx"],"sourcesContent":["import { Editor, Element, Node, Text, Transforms } from 'slate'\nimport { ReactEditor } from 'slate-react'\n\nimport { getCommonBlock } from './getCommonBlock.js'\nimport { isListActive } from './isListActive.js'\nimport { listTypes } from './listTypes.js'\nimport { unwrapList } from './unwrapList.js'\n\nexport const toggleList = (editor: Editor, format: string): void => {\n  let currentListFormat: string\n\n  if (isListActive(editor, 'ol')) {\n    currentListFormat = 'ol'\n  }\n  if (isListActive(editor, 'ul')) {\n    currentListFormat = 'ul'\n  }\n\n  // If the format is currently active,\n  // remove the list\n  if (currentListFormat === format) {\n    const selectedLeaf = Node.descendant(editor, editor.selection.anchor.path)\n\n    // If on an empty bullet, leave the above list alone\n    // and unwrap only the active bullet\n    if (Text.isText(selectedLeaf) && String(selectedLeaf.text).length === 0) {\n      Transforms.unwrapNodes(editor, {\n        match: (n) => Element.isElement(n) && listTypes.includes(n.type),\n        mode: 'lowest',\n        split: true,\n      })\n\n      Transforms.setNodes(editor, { type: undefined })\n    } else {\n      // Otherwise, we need to unset li on all lis in the parent list\n      // and unwrap the parent list itself\n      const [, listPath] = getCommonBlock(editor, (n) => Element.isElement(n) && n.type === format)\n      unwrapList(editor, listPath)\n    }\n\n    // Otherwise, if a list is active and we are changing it,\n    // change it\n  } else if (currentListFormat && currentListFormat !== format) {\n    Transforms.setNodes(\n      editor,\n      {\n        type: format,\n      },\n      {\n        match: (node) => Element.isElement(node) && listTypes.includes(node.type),\n        mode: 'lowest',\n      },\n    )\n    // Otherwise we can assume that we should just activate the list\n  } else {\n    Transforms.wrapNodes(editor, { type: format, children: [] })\n\n    const [, parentNodePath] = getCommonBlock(\n      editor,\n      (node) => Element.isElement(node) && node.type === format,\n    )\n\n    // Only set li on nodes that don't have type\n    Transforms.setNodes(\n      editor,\n      { type: 'li' },\n      {\n        match: (node, path) => {\n          const match =\n            Element.isElement(node) &&\n            typeof node.type === 'undefined' &&\n            path.length === parentNodePath.length + 1\n\n          return match\n        },\n        voids: true,\n      },\n    )\n\n    // Wrap nodes that do have a type with an li\n    // so as to not lose their existing formatting\n    const nodesToWrap = Array.from(\n      Editor.nodes(editor, {\n        match: (node, path) => {\n          const match =\n            Element.isElement(node) &&\n            typeof node.type !== 'undefined' &&\n            node.type !== 'li' &&\n            path.length === parentNodePath.length + 1\n\n          return match\n        },\n      }),\n    )\n\n    nodesToWrap.forEach(([, path]) => {\n      Transforms.wrapNodes(editor, { type: 'li', children: [] }, { at: path })\n    })\n  }\n\n  ReactEditor.focus(editor)\n}\n"],"names":["Editor","Element","Node","Text","Transforms","ReactEditor","getCommonBlock","isListActive","listTypes","unwrapList","toggleList","editor","format","currentListFormat","selectedLeaf","descendant","selection","anchor","path","isText","String","text","length","unwrapNodes","match","n","isElement","includes","type","mode","split","setNodes","undefined","listPath","node","wrapNodes","children","parentNodePath","voids","nodesToWrap","Array","from","nodes","forEach","at","focus"],"mappings":"AAAA,SAASA,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAAEC,IAAI,EAAEC,UAAU,QAAQ,QAAO;AAC/D,SAASC,WAAW,QAAQ,cAAa;AAEzC,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,SAAS,QAAQ,iBAAgB;AAC1C,SAASC,UAAU,QAAQ,kBAAiB;AAE5C,OAAO,MAAMC,aAAa,CAACC,QAAgBC;IACzC,IAAIC;IAEJ,IAAIN,aAAaI,QAAQ,OAAO;QAC9BE,oBAAoB;IACtB;IACA,IAAIN,aAAaI,QAAQ,OAAO;QAC9BE,oBAAoB;IACtB;IAEA,qCAAqC;IACrC,kBAAkB;IAClB,IAAIA,sBAAsBD,QAAQ;QAChC,MAAME,eAAeZ,KAAKa,UAAU,CAACJ,QAAQA,OAAOK,SAAS,CAACC,MAAM,CAACC,IAAI;QAEzE,oDAAoD;QACpD,oCAAoC;QACpC,IAAIf,KAAKgB,MAAM,CAACL,iBAAiBM,OAAON,aAAaO,IAAI,EAAEC,MAAM,KAAK,GAAG;YACvElB,WAAWmB,WAAW,CAACZ,QAAQ;gBAC7Ba,OAAO,CAACC,IAAMxB,QAAQyB,SAAS,CAACD,MAAMjB,UAAUmB,QAAQ,CAACF,EAAEG,IAAI;gBAC/DC,MAAM;gBACNC,OAAO;YACT;YAEA1B,WAAW2B,QAAQ,CAACpB,QAAQ;gBAAEiB,MAAMI;YAAU;QAChD,OAAO;YACL,+DAA+D;YAC/D,oCAAoC;YACpC,MAAM,GAAGC,SAAS,GAAG3B,eAAeK,QAAQ,CAACc,IAAMxB,QAAQyB,SAAS,CAACD,MAAMA,EAAEG,IAAI,KAAKhB;YACtFH,WAAWE,QAAQsB;QACrB;IAEA,yDAAyD;IACzD,YAAY;IACd,OAAO,IAAIpB,qBAAqBA,sBAAsBD,QAAQ;QAC5DR,WAAW2B,QAAQ,CACjBpB,QACA;YACEiB,MAAMhB;QACR,GACA;YACEY,OAAO,CAACU,OAASjC,QAAQyB,SAAS,CAACQ,SAAS1B,UAAUmB,QAAQ,CAACO,KAAKN,IAAI;YACxEC,MAAM;QACR;IAEF,gEAAgE;IAClE,OAAO;QACLzB,WAAW+B,SAAS,CAACxB,QAAQ;YAAEiB,MAAMhB;YAAQwB,UAAU,EAAE;QAAC;QAE1D,MAAM,GAAGC,eAAe,GAAG/B,eACzBK,QACA,CAACuB,OAASjC,QAAQyB,SAAS,CAACQ,SAASA,KAAKN,IAAI,KAAKhB;QAGrD,4CAA4C;QAC5CR,WAAW2B,QAAQ,CACjBpB,QACA;YAAEiB,MAAM;QAAK,GACb;YACEJ,OAAO,CAACU,MAAMhB;gBACZ,MAAMM,QACJvB,QAAQyB,SAAS,CAACQ,SAClB,OAAOA,KAAKN,IAAI,KAAK,eACrBV,KAAKI,MAAM,KAAKe,eAAef,MAAM,GAAG;gBAE1C,OAAOE;YACT;YACAc,OAAO;QACT;QAGF,4CAA4C;QAC5C,8CAA8C;QAC9C,MAAMC,cAAcC,MAAMC,IAAI,CAC5BzC,OAAO0C,KAAK,CAAC/B,QAAQ;YACnBa,OAAO,CAACU,MAAMhB;gBACZ,MAAMM,QACJvB,QAAQyB,SAAS,CAACQ,SAClB,OAAOA,KAAKN,IAAI,KAAK,eACrBM,KAAKN,IAAI,KAAK,QACdV,KAAKI,MAAM,KAAKe,eAAef,MAAM,GAAG;gBAE1C,OAAOE;YACT;QACF;QAGFe,YAAYI,OAAO,CAAC,CAAC,GAAGzB,KAAK;YAC3Bd,WAAW+B,SAAS,CAACxB,QAAQ;gBAAEiB,MAAM;gBAAMQ,UAAU,EAAE;YAAC,GAAG;gBAAEQ,IAAI1B;YAAK;QACxE;IACF;IAEAb,YAAYwC,KAAK,CAAClC;AACpB,EAAC"}