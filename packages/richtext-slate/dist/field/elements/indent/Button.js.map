{"version":3,"sources":["../../../../src/field/elements/indent/Button.tsx"],"sourcesContent":["'use client'\n\nimport React, { useCallback } from 'react'\nimport { Editor, Element, Text, Transforms } from 'slate'\nimport { ReactEditor, useSlate } from 'slate-react'\n\nimport type { ElementNode } from '../../../types.js'\n\nimport { IndentLeft } from '../../icons/IndentLeft/index.js'\nimport { IndentRight } from '../../icons/IndentRight/index.js'\nimport { baseClass } from '../Button.js'\nimport { getCommonBlock } from '../getCommonBlock.js'\nimport { isElementActive } from '../isActive.js'\nimport { isBlockElement } from '../isBlockElement.js'\nimport { listTypes } from '../listTypes.js'\nimport { unwrapList } from '../unwrapList.js'\nimport { indentType } from './shared.js'\n\nexport const IndentButton: React.FC = () => {\n  const editor = useSlate()\n  const handleIndent = useCallback(\n    (e, dir) => {\n      e.preventDefault()\n\n      if (dir === 'left') {\n        if (isElementActive(editor, 'li')) {\n          const [, listPath] = getCommonBlock(\n            editor,\n            (n) => Element.isElement(n) && listTypes.includes(n.type),\n          )\n\n          const matchedParentList = Editor.above(editor, {\n            at: listPath,\n            match: (n: ElementNode) => !Editor.isEditor(n) && isBlockElement(editor, n),\n          })\n\n          if (matchedParentList) {\n            const [parentListItem, parentListItemPath] = matchedParentList\n\n            if (parentListItem.children.length > 1) {\n              // Remove nested list\n              Transforms.unwrapNodes(editor, {\n                at: parentListItemPath,\n                match: (node, path) => {\n                  const matches =\n                    !Editor.isEditor(node) &&\n                    Element.isElement(node) &&\n                    listTypes.includes(node.type) &&\n                    path.length === parentListItemPath.length + 1\n\n                  return matches\n                },\n              })\n\n              // Set li type on any children that don't have a type\n              Transforms.setNodes(\n                editor,\n                { type: 'li' },\n                {\n                  at: parentListItemPath,\n                  match: (node, path) => {\n                    const matches =\n                      !Editor.isEditor(node) &&\n                      Element.isElement(node) &&\n                      node.type !== 'li' &&\n                      path.length === parentListItemPath.length + 1\n\n                    return matches\n                  },\n                },\n              )\n\n              // Parent list item path has changed at this point\n              // so we need to re-fetch the parent node\n              const [newParentNode] = Editor.node(editor, parentListItemPath)\n\n              // If the parent node is an li,\n              // lift all li nodes within\n              if (Element.isElement(newParentNode) && newParentNode.type === 'li') {\n                // Lift the nested lis\n                Transforms.liftNodes(editor, {\n                  at: parentListItemPath,\n                  match: (node, path) => {\n                    const matches =\n                      !Editor.isEditor(node) &&\n                      Element.isElement(node) &&\n                      path.length === parentListItemPath.length + 1 &&\n                      node.type === 'li'\n\n                    return matches\n                  },\n                })\n              }\n            } else {\n              Transforms.unwrapNodes(editor, {\n                at: parentListItemPath,\n                match: (node, path) => {\n                  return (\n                    Element.isElement(node) &&\n                    node.type === 'li' &&\n                    path.length === parentListItemPath.length\n                  )\n                },\n              })\n\n              Transforms.unwrapNodes(editor, {\n                match: (n) => Element.isElement(n) && listTypes.includes(n.type),\n              })\n            }\n          } else {\n            unwrapList(editor, listPath)\n          }\n        } else {\n          Transforms.unwrapNodes(editor, {\n            match: (n) => Element.isElement(n) && n.type === indentType,\n            mode: 'lowest',\n            split: true,\n          })\n        }\n      }\n\n      if (dir === 'right') {\n        const isCurrentlyOL = isElementActive(editor, 'ol')\n        const isCurrentlyUL = isElementActive(editor, 'ul')\n\n        if (isCurrentlyOL || isCurrentlyUL) {\n          // Get the path of the first selected li -\n          // Multiple lis could be selected\n          // and the selection may start in the middle of the first li\n          const [[, firstSelectedLIPath]] = Array.from(\n            Editor.nodes(editor, {\n              match: (node) => Element.isElement(node) && node.type === 'li',\n              mode: 'lowest',\n            }),\n          )\n\n          // Is the first selected li the first in its list?\n          const hasPrecedingLI = firstSelectedLIPath[firstSelectedLIPath.length - 1] > 0\n\n          // If the first selected li is NOT the first in its list,\n          // we need to inject it into the prior li\n          if (hasPrecedingLI) {\n            const [, precedingLIPath] = Editor.previous(editor, {\n              at: firstSelectedLIPath,\n            })\n\n            const [precedingLIChildren] = Editor.node(editor, [...precedingLIPath, 0])\n            const precedingLIChildrenIsText = Text.isText(precedingLIChildren)\n\n            if (precedingLIChildrenIsText) {\n              // Wrap the prior li text content so that it can be nested next to a list\n              Transforms.wrapNodes(editor, { children: [] }, { at: [...precedingLIPath, 0] })\n            }\n\n            // Move the selected lis after the prior li contents\n            Transforms.moveNodes(editor, {\n              match: (node) => Element.isElement(node) && node.type === 'li',\n              mode: 'lowest',\n              to: [...precedingLIPath, 1],\n            })\n\n            // Wrap the selected lis in a new list\n            Transforms.wrapNodes(\n              editor,\n              {\n                type: isCurrentlyOL ? 'ol' : 'ul',\n                children: [],\n              },\n              {\n                match: (node) => Element.isElement(node) && node.type === 'li',\n                mode: 'lowest',\n              },\n            )\n          } else {\n            // Otherwise, just wrap the node in a list / li\n            Transforms.wrapNodes(\n              editor,\n              {\n                type: isCurrentlyOL ? 'ol' : 'ul',\n                children: [{ type: 'li', children: [] }],\n              },\n              {\n                match: (node) => Element.isElement(node) && node.type === 'li',\n                mode: 'lowest',\n              },\n            )\n          }\n        } else {\n          Transforms.wrapNodes(editor, { type: indentType, children: [] })\n        }\n      }\n\n      ReactEditor.focus(editor)\n    },\n    [editor],\n  )\n\n  const canDeIndent = isElementActive(editor, 'li') || isElementActive(editor, indentType)\n\n  return (\n    <React.Fragment>\n      <button\n        className={[baseClass, !canDeIndent && `${baseClass}--disabled`].filter(Boolean).join(' ')}\n        onClick={canDeIndent ? (e) => handleIndent(e, 'left') : undefined}\n        type=\"button\"\n      >\n        <IndentLeft />\n      </button>\n      <button className={baseClass} onClick={(e) => handleIndent(e, 'right')} type=\"button\">\n        <IndentRight />\n      </button>\n    </React.Fragment>\n  )\n}\n"],"names":["React","useCallback","Editor","Element","Text","Transforms","ReactEditor","useSlate","IndentLeft","IndentRight","baseClass","getCommonBlock","isElementActive","isBlockElement","listTypes","unwrapList","indentType","IndentButton","editor","handleIndent","e","dir","preventDefault","listPath","n","isElement","includes","type","matchedParentList","above","at","match","isEditor","parentListItem","parentListItemPath","children","length","unwrapNodes","node","path","matches","setNodes","newParentNode","liftNodes","mode","split","isCurrentlyOL","isCurrentlyUL","firstSelectedLIPath","Array","from","nodes","hasPrecedingLI","precedingLIPath","previous","precedingLIChildren","precedingLIChildrenIsText","isText","wrapNodes","moveNodes","to","focus","canDeIndent","Fragment","button","className","filter","Boolean","join","onClick","undefined"],"mappings":"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"}