{"version":3,"sources":["../../src/data/recurseNestedFields.ts"],"sourcesContent":["import type { Field, FlattenedBlock, PayloadRequest, PopulateType } from 'payload'\n\nimport { fieldAffectsData, fieldHasSubFields, fieldIsArrayType, tabHasName } from 'payload/shared'\n\nimport { populate } from './populate.js'\nimport { recurseRichText } from './richTextRelationshipPromise.js'\n\ntype NestedRichTextFieldsArgs = {\n  currentDepth?: number\n  data: unknown\n  depth: number\n  draft: boolean\n  fields: Field[]\n  overrideAccess: boolean\n  populateArg?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  showHiddenFields: boolean\n}\n\nexport const recurseNestedFields = ({\n  currentDepth = 0,\n  data,\n  depth,\n  draft,\n  fields,\n  overrideAccess = false,\n  populateArg,\n  populationPromises,\n  req,\n  showHiddenFields,\n}: NestedRichTextFieldsArgs): void => {\n  fields.forEach((field) => {\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (field.type === 'relationship') {\n        if (field.hasMany && Array.isArray(data[field.name])) {\n          if (Array.isArray(field.relationTo)) {\n            data[field.name].forEach(({ relationTo, value }, i) => {\n              const collection = req.payload.collections[relationTo]\n              if (collection) {\n                populationPromises.push(\n                  populate({\n                    id: value,\n                    collection,\n                    currentDepth,\n                    data: data[field.name],\n                    depth,\n                    draft,\n                    field,\n                    key: i,\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n              }\n            })\n          } else {\n            data[field.name].forEach((id, i) => {\n              const collection = req.payload.collections[field.relationTo as string]\n              if (collection) {\n                populationPromises.push(\n                  populate({\n                    id,\n                    collection,\n                    currentDepth,\n                    data: data[field.name],\n                    depth,\n                    draft,\n                    field,\n                    key: i,\n                    overrideAccess,\n                    req,\n                    select:\n                      populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                    showHiddenFields,\n                  }),\n                )\n              }\n            })\n          }\n        } else if (\n          Array.isArray(field.relationTo) &&\n          data[field.name]?.value &&\n          data[field.name]?.relationTo\n        ) {\n          if (!('hasMany' in field) || !field.hasMany) {\n            const collection = req.payload.collections[data[field.name].relationTo]\n            populationPromises.push(\n              populate({\n                id: data[field.name].value,\n                collection,\n                currentDepth,\n                data: data[field.name],\n                depth,\n                draft,\n                field,\n                key: 'value',\n                overrideAccess,\n                req,\n                select: populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n                showHiddenFields,\n              }),\n            )\n          }\n        }\n      }\n      if (typeof data[field.name] !== 'undefined' && typeof field.relationTo === 'string') {\n        const collection = req.payload.collections[field.relationTo]\n        populationPromises.push(\n          populate({\n            id: data[field.name],\n            collection,\n            currentDepth,\n            data,\n            depth,\n            draft,\n            field,\n            key: field.name,\n            overrideAccess,\n            req,\n            select: populateArg?.[collection.config.slug] ?? collection.config.defaultPopulate,\n            showHiddenFields,\n          }),\n        )\n      }\n    } else if (fieldHasSubFields(field) && !fieldIsArrayType(field)) {\n      if (fieldAffectsData(field) && typeof data[field.name] === 'object') {\n        recurseNestedFields({\n          currentDepth,\n          data: data[field.name],\n          depth,\n          draft,\n          fields: field.fields,\n          overrideAccess,\n          populateArg,\n          populationPromises,\n          req,\n          showHiddenFields,\n        })\n      } else {\n        recurseNestedFields({\n          currentDepth,\n          data,\n          depth,\n          draft,\n          fields: field.fields,\n          overrideAccess,\n          populateArg,\n          populationPromises,\n          req,\n          showHiddenFields,\n        })\n      }\n    } else if (field.type === 'tabs') {\n      field.tabs.forEach((tab) => {\n        recurseNestedFields({\n          currentDepth,\n          data: tabHasName(tab) ? data[tab.name] : data,\n          depth,\n          draft,\n          fields: tab.fields,\n          overrideAccess,\n          populateArg,\n          populationPromises,\n          req,\n          showHiddenFields,\n        })\n      })\n    } else if (Array.isArray(data[field.name])) {\n      if (field.type === 'blocks') {\n        data[field.name].forEach((row, i) => {\n          const block =\n            req.payload.blocks[row?.blockType] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (block) => typeof block !== 'string' && block.slug === row?.blockType,\n            ) as FlattenedBlock | undefined)\n          if (block) {\n            recurseNestedFields({\n              currentDepth,\n              data: data[field.name][i],\n              depth,\n              draft,\n              fields: block.fields,\n              overrideAccess,\n              populateArg,\n              populationPromises,\n              req,\n              showHiddenFields,\n            })\n          }\n        })\n      }\n\n      if (field.type === 'array') {\n        data[field.name].forEach((_, i) => {\n          recurseNestedFields({\n            currentDepth,\n            data: data[field.name][i],\n            depth,\n            draft,\n            fields: field.fields,\n            overrideAccess,\n            populateArg,\n            populationPromises,\n            req,\n            showHiddenFields,\n          })\n        })\n      }\n    }\n\n    if (field.type === 'richText' && Array.isArray(data[field.name])) {\n      data[field.name].forEach((node) => {\n        if (Array.isArray(node.children)) {\n          recurseRichText({\n            children: node.children,\n            currentDepth,\n            depth,\n            draft,\n            field,\n            overrideAccess,\n            populationPromises,\n            req,\n            showHiddenFields,\n          })\n        }\n      })\n    }\n  })\n}\n"],"names":["fieldAffectsData","fieldHasSubFields","fieldIsArrayType","tabHasName","populate","recurseRichText","recurseNestedFields","currentDepth","data","depth","draft","fields","overrideAccess","populateArg","populationPromises","req","showHiddenFields","forEach","field","type","hasMany","Array","isArray","name","relationTo","value","i","collection","payload","collections","push","id","key","select","config","slug","defaultPopulate","tabs","tab","row","block","blocks","blockType","blockReferences","find","_","node","children"],"mappings":"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"}