{"version":3,"sources":["../src/migrate.ts"],"sourcesContent":["import type { Payload } from 'payload'\n\nimport {\n  commitTransaction,\n  createLocalReq,\n  initTransaction,\n  killTransaction,\n  readMigrationFiles,\n} from 'payload'\nimport prompts from 'prompts'\n\nimport type { DrizzleAdapter, Migration } from './types.js'\n\nimport { getTransaction } from './utilities/getTransaction.js'\nimport { migrationTableExists } from './utilities/migrationTableExists.js'\nimport { parseError } from './utilities/parseError.js'\n\nexport const migrate: DrizzleAdapter['migrate'] = async function migrate(\n  this: DrizzleAdapter,\n  args,\n): Promise<void> {\n  const { payload } = this\n  const migrationFiles = args?.migrations || (await readMigrationFiles({ payload }))\n\n  if (!migrationFiles.length) {\n    payload.logger.info({ msg: 'No migrations to run.' })\n    return\n  }\n\n  if ('createExtensions' in this && typeof this.createExtensions === 'function') {\n    await this.createExtensions()\n  }\n\n  let latestBatch = 0\n  let migrationsInDB = []\n\n  const hasMigrationTable = await migrationTableExists(this)\n\n  if (hasMigrationTable) {\n    ;({ docs: migrationsInDB } = await payload.find({\n      collection: 'payload-migrations',\n      limit: 0,\n      sort: '-name',\n    }))\n    if (Number(migrationsInDB?.[0]?.batch) > 0) {\n      latestBatch = Number(migrationsInDB[0]?.batch)\n    }\n  }\n\n  if (migrationsInDB.find((m) => m.batch === -1)) {\n    const { confirm: runMigrations } = await prompts(\n      {\n        name: 'confirm',\n        type: 'confirm',\n        initial: false,\n        message:\n          \"It looks like you've run Payload in dev mode, meaning you've dynamically pushed changes to your database.\\n\\n\" +\n          \"If you'd like to run migrations, data loss will occur. Would you like to proceed?\",\n      },\n      {\n        onCancel: () => {\n          process.exit(0)\n        },\n      },\n    )\n\n    if (!runMigrations) {\n      process.exit(0)\n    }\n  }\n\n  const newBatch = latestBatch + 1\n\n  // Execute 'up' function for each migration sequentially\n  for (const migration of migrationFiles) {\n    const alreadyRan = migrationsInDB.find((existing) => existing.name === migration.name)\n\n    // If already ran, skip\n    if (alreadyRan) {\n      continue\n    }\n\n    await runMigrationFile(payload, migration, newBatch)\n  }\n}\n\nasync function runMigrationFile(payload: Payload, migration: Migration, batch: number) {\n  const start = Date.now()\n  const req = await createLocalReq({}, payload)\n\n  payload.logger.info({ msg: `Migrating: ${migration.name}` })\n\n  try {\n    await initTransaction(req)\n    const db = await getTransaction(payload.db as DrizzleAdapter, req)\n    await migration.up({ db, payload, req })\n    payload.logger.info({ msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)` })\n    await payload.create({\n      collection: 'payload-migrations',\n      data: {\n        name: migration.name,\n        batch,\n      },\n      req,\n    })\n    await commitTransaction(req)\n  } catch (err: unknown) {\n    await killTransaction(req)\n    payload.logger.error({\n      err,\n      msg: parseError(err, `Error running migration ${migration.name}`),\n    })\n    process.exit(1)\n  }\n}\n"],"names":["commitTransaction","createLocalReq","initTransaction","killTransaction","readMigrationFiles","prompts","getTransaction","migrationTableExists","parseError","migrate","args","payload","migrationFiles","migrations","length","logger","info","msg","createExtensions","latestBatch","migrationsInDB","hasMigrationTable","docs","find","collection","limit","sort","Number","batch","m","confirm","runMigrations","name","type","initial","message","onCancel","process","exit","newBatch","migration","alreadyRan","existing","runMigrationFile","start","Date","now","req","db","up","create","data","err","error"],"mappings":"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"}