{"version":3,"sources":["../../../src/transform/write/blocks.ts"],"sourcesContent":["import type { FlattenedBlock, FlattenedBlocksField } from 'payload'\n\nimport { fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlockRowToInsert, RelationshipToDelete } from './types.js'\n\nimport { traverseFields } from './traverseFields.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  baseTableName: string\n  blocks: {\n    [blockType: string]: BlockRowToInsert[]\n  }\n  blocksToDelete: Set<string>\n  data: Record<string, unknown>[]\n  field: FlattenedBlocksField\n  locale?: string\n  numbers: Record<string, unknown>[]\n  parentIsLocalized: boolean\n  path: string\n  relationships: Record<string, unknown>[]\n  relationshipsToDelete: RelationshipToDelete[]\n  selects: {\n    [tableName: string]: Record<string, unknown>[]\n  }\n  texts: Record<string, unknown>[]\n  /**\n   * Set to a locale code if this set of fields is traversed within a\n   * localized array or block field\n   */\n  withinArrayOrBlockLocale?: string\n}\nexport const transformBlocks = ({\n  adapter,\n  baseTableName,\n  blocks,\n  blocksToDelete,\n  data,\n  field,\n  locale,\n  numbers,\n  parentIsLocalized,\n  path,\n  relationships,\n  relationshipsToDelete,\n  selects,\n  texts,\n  withinArrayOrBlockLocale,\n}: Args) => {\n  data.forEach((blockRow, i) => {\n    if (typeof blockRow.blockType !== 'string') {\n      return\n    }\n\n    const matchedBlock =\n      adapter.payload.blocks[blockRow.blockType] ??\n      ((field.blockReferences ?? field.blocks).find(\n        (block) => typeof block !== 'string' && block.slug === blockRow.blockType,\n      ) as FlattenedBlock | undefined)\n\n    if (!matchedBlock) {\n      return\n    }\n    const blockType = toSnakeCase(blockRow.blockType)\n\n    if (!blocks[blockType]) {\n      blocks[blockType] = []\n    }\n\n    const newRow: BlockRowToInsert = {\n      arrays: {},\n      locales: {},\n      row: {\n        _order: i + 1,\n        _path: `${path}${field.name}`,\n      },\n    }\n\n    if (fieldShouldBeLocalized({ field, parentIsLocalized }) && locale) {\n      newRow.row._locale = locale\n    }\n    if (withinArrayOrBlockLocale) {\n      newRow.row._locale = withinArrayOrBlockLocale\n    }\n\n    const blockTableName = adapter.tableNameMap.get(`${baseTableName}_blocks_${blockType}`)\n\n    const hasUUID = adapter.tables[blockTableName]._uuid\n\n    // If we have declared a _uuid field on arrays,\n    // that means the ID has to be unique,\n    // and our ids within arrays are not unique.\n    // So move the ID to a uuid field for storage\n    // and allow the database to generate a serial id automatically\n    if (hasUUID) {\n      newRow.row._uuid = blockRow.id\n      delete blockRow.id\n    }\n\n    traverseFields({\n      adapter,\n      arrays: newRow.arrays,\n      baseTableName,\n      blocks,\n      blocksToDelete,\n      columnPrefix: '',\n      data: blockRow,\n      fieldPrefix: '',\n      fields: matchedBlock.flattenedFields,\n      insideArrayOrBlock: true,\n      locales: newRow.locales,\n      numbers,\n      parentIsLocalized: parentIsLocalized || field.localized,\n      parentTableName: blockTableName,\n      path: `${path || ''}${field.name}.${i}.`,\n      relationships,\n      relationshipsToDelete,\n      row: newRow.row,\n      selects,\n      texts,\n      withinArrayOrBlockLocale,\n    })\n\n    blocks[blockType].push(newRow)\n  })\n}\n"],"names":["fieldShouldBeLocalized","toSnakeCase","traverseFields","transformBlocks","adapter","baseTableName","blocks","blocksToDelete","data","field","locale","numbers","parentIsLocalized","path","relationships","relationshipsToDelete","selects","texts","withinArrayOrBlockLocale","forEach","blockRow","i","blockType","matchedBlock","payload","blockReferences","find","block","slug","newRow","arrays","locales","row","_order","_path","name","_locale","blockTableName","tableNameMap","get","hasUUID","tables","_uuid","id","columnPrefix","fieldPrefix","fields","flattenedFields","insideArrayOrBlock","localized","parentTableName","push"],"mappings":"AAEA,SAASA,sBAAsB,QAAQ,iBAAgB;AACvD,OAAOC,iBAAiB,gBAAe;AAKvC,SAASC,cAAc,QAAQ,sBAAqB;AA2BpD,OAAO,MAAMC,kBAAkB,CAAC,EAC9BC,OAAO,EACPC,aAAa,EACbC,MAAM,EACNC,cAAc,EACdC,IAAI,EACJC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,iBAAiB,EACjBC,IAAI,EACJC,aAAa,EACbC,qBAAqB,EACrBC,OAAO,EACPC,KAAK,EACLC,wBAAwB,EACnB;IACLV,KAAKW,OAAO,CAAC,CAACC,UAAUC;QACtB,IAAI,OAAOD,SAASE,SAAS,KAAK,UAAU;YAC1C;QACF;QAEA,MAAMC,eACJnB,QAAQoB,OAAO,CAAClB,MAAM,CAACc,SAASE,SAAS,CAAC,IACzC,AAACb,CAAAA,MAAMgB,eAAe,IAAIhB,MAAMH,MAAM,AAAD,EAAGoB,IAAI,CAC3C,CAACC,QAAU,OAAOA,UAAU,YAAYA,MAAMC,IAAI,KAAKR,SAASE,SAAS;QAG7E,IAAI,CAACC,cAAc;YACjB;QACF;QACA,MAAMD,YAAYrB,YAAYmB,SAASE,SAAS;QAEhD,IAAI,CAAChB,MAAM,CAACgB,UAAU,EAAE;YACtBhB,MAAM,CAACgB,UAAU,GAAG,EAAE;QACxB;QAEA,MAAMO,SAA2B;YAC/BC,QAAQ,CAAC;YACTC,SAAS,CAAC;YACVC,KAAK;gBACHC,QAAQZ,IAAI;gBACZa,OAAO,GAAGrB,OAAOJ,MAAM0B,IAAI,EAAE;YAC/B;QACF;QAEA,IAAInC,uBAAuB;YAAES;YAAOG;QAAkB,MAAMF,QAAQ;YAClEmB,OAAOG,GAAG,CAACI,OAAO,GAAG1B;QACvB;QACA,IAAIQ,0BAA0B;YAC5BW,OAAOG,GAAG,CAACI,OAAO,GAAGlB;QACvB;QAEA,MAAMmB,iBAAiBjC,QAAQkC,YAAY,CAACC,GAAG,CAAC,GAAGlC,cAAc,QAAQ,EAAEiB,WAAW;QAEtF,MAAMkB,UAAUpC,QAAQqC,MAAM,CAACJ,eAAe,CAACK,KAAK;QAEpD,+CAA+C;QAC/C,sCAAsC;QACtC,4CAA4C;QAC5C,6CAA6C;QAC7C,+DAA+D;QAC/D,IAAIF,SAAS;YACXX,OAAOG,GAAG,CAACU,KAAK,GAAGtB,SAASuB,EAAE;YAC9B,OAAOvB,SAASuB,EAAE;QACpB;QAEAzC,eAAe;YACbE;YACA0B,QAAQD,OAAOC,MAAM;YACrBzB;YACAC;YACAC;YACAqC,cAAc;YACdpC,MAAMY;YACNyB,aAAa;YACbC,QAAQvB,aAAawB,eAAe;YACpCC,oBAAoB;YACpBjB,SAASF,OAAOE,OAAO;YACvBpB;YACAC,mBAAmBA,qBAAqBH,MAAMwC,SAAS;YACvDC,iBAAiBb;YACjBxB,MAAM,GAAGA,QAAQ,KAAKJ,MAAM0B,IAAI,CAAC,CAAC,EAAEd,EAAE,CAAC,CAAC;YACxCP;YACAC;YACAiB,KAAKH,OAAOG,GAAG;YACfhB;YACAC;YACAC;QACF;QAEAZ,MAAM,CAACgB,UAAU,CAAC6B,IAAI,CAACtB;IACzB;AACF,EAAC"}