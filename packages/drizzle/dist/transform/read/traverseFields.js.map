{"version":3,"sources":["../../../src/transform/read/traverseFields.ts"],"sourcesContent":["import type { FlattenedBlock, FlattenedField, JoinQuery, SanitizedConfig } from 'payload'\n\nimport { fieldIsVirtual, fieldShouldBeLocalized } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\n\nimport type { DrizzleAdapter } from '../../types.js'\nimport type { BlocksMap } from '../../utilities/createBlocksMap.js'\n\nimport { transformHasManyNumber } from './hasManyNumber.js'\nimport { transformHasManyText } from './hasManyText.js'\nimport { transformRelationship } from './relationship.js'\n\ntype TraverseFieldsArgs = {\n  /**\n   * The DB adapter\n   */\n  adapter: DrizzleAdapter\n  /**\n   * Pre-formatted blocks map\n   */\n  blocks: BlocksMap\n  /**\n   * The full Payload config\n   */\n  config: SanitizedConfig\n  currentTableName: string\n  /**\n   * The data reference to be mutated within this recursive function\n   */\n  dataRef: Record<string, unknown>\n  /**\n   * Data that needs to be removed from the result after all fields have populated\n   */\n  deletions: (() => void)[]\n  /**\n   * Column prefix can be built up by group and named tab fields\n   */\n  fieldPrefix: string\n  /**\n   * An array of Payload fields to traverse\n   */\n  fields: FlattenedField[]\n  /**\n   *\n   */\n  joinQuery?: JoinQuery\n  /**\n   * All hasMany number fields, as returned by Drizzle, keyed on an object by field path\n   */\n  numbers: Record<string, Record<string, unknown>[]>\n  parentIsLocalized: boolean\n  /**\n   * The current field path (in dot notation), used to merge in relationships\n   */\n  path: string\n  /**\n   * All related documents, as returned by Drizzle, keyed on an object by field path\n   */\n  relationships: Record<string, Record<string, unknown>[]>\n  /**\n   * Data structure representing the nearest table from db\n   */\n  table: Record<string, unknown>\n  tablePath: string\n  /**\n   * All hasMany text fields, as returned by Drizzle, keyed on an object by field path\n   */\n  texts: Record<string, Record<string, unknown>[]>\n  topLevelTableName: string\n  /**\n   * Set to a locale if this group of fields is within a localized array or block.\n   */\n  withinArrayOrBlockLocale?: string\n}\n\n// Traverse fields recursively, transforming data\n// for each field type into required Payload shape\nexport const traverseFields = <T extends Record<string, unknown>>({\n  adapter,\n  blocks,\n  config,\n  currentTableName,\n  dataRef,\n  deletions,\n  fieldPrefix,\n  fields,\n  joinQuery,\n  numbers,\n  parentIsLocalized,\n  path,\n  relationships,\n  table,\n  tablePath,\n  texts,\n  topLevelTableName,\n  withinArrayOrBlockLocale,\n}: TraverseFieldsArgs): T => {\n  const sanitizedPath = path ? `${path}.` : path\n\n  const formatted = fields.reduce((result, field) => {\n    if (fieldIsVirtual(field)) {\n      return result\n    }\n\n    const fieldName = `${fieldPrefix || ''}${field.name}`\n    let fieldData = table[fieldName]\n    const localizedFieldData = {}\n    const valuesToTransform: {\n      ref: Record<string, unknown>\n      table: Record<string, unknown>\n    }[] = []\n\n    if (fieldPrefix) {\n      deletions.push(() => delete table[fieldName])\n    }\n\n    const isLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    if (field.type === 'array') {\n      const arrayTableName = adapter.tableNameMap.get(\n        `${currentTableName}_${tablePath}${toSnakeCase(field.name)}`,\n      )\n\n      if (field.dbName) {\n        fieldData = table[`_${arrayTableName}`]\n      }\n\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((arrayResult, row) => {\n            if (typeof row._locale === 'string') {\n              if (!arrayResult[row._locale]) {\n                arrayResult[row._locale] = []\n              }\n              const locale = row._locale\n              const data = {}\n              delete row._locale\n              if (row._uuid) {\n                row.id = row._uuid\n                delete row._uuid\n              }\n\n              const rowResult = traverseFields<T>({\n                adapter,\n                blocks,\n                config,\n                currentTableName: arrayTableName,\n                dataRef: data,\n                deletions,\n                fieldPrefix: '',\n                fields: field.flattenedFields,\n                numbers,\n                parentIsLocalized: parentIsLocalized || field.localized,\n                path: `${sanitizedPath}${field.name}.${row._order - 1}`,\n                relationships,\n                table: row,\n                tablePath: '',\n                texts,\n                topLevelTableName,\n                withinArrayOrBlockLocale: locale,\n              })\n\n              if ('_order' in rowResult) {\n                delete rowResult._order\n              }\n\n              arrayResult[locale].push(rowResult)\n            }\n\n            return arrayResult\n          }, {})\n        } else {\n          result[field.name] = fieldData.reduce((acc, row, i) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if ('_order' in row) {\n              delete row._order\n            }\n\n            if (\n              !withinArrayOrBlockLocale ||\n              (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n            ) {\n              if (row._locale) {\n                delete row._locale\n              }\n\n              acc.push(\n                traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: arrayTableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: field.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${sanitizedPath}${field.name}.${i}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale,\n                }),\n              )\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'blocks') {\n      const blockFieldPath = `${sanitizedPath}${field.name}`\n      const blocksByPath = blocks[blockFieldPath]\n\n      if (Array.isArray(blocksByPath)) {\n        if (isLocalized) {\n          result[field.name] = {}\n\n          blocksByPath.forEach((row) => {\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n            if (typeof row._locale === 'string') {\n              if (!result[field.name][row._locale]) {\n                result[field.name][row._locale] = []\n              }\n              result[field.name][row._locale].push(row)\n              delete row._locale\n            }\n          })\n\n          Object.entries(result[field.name]).forEach(([locale, localizedBlocks]) => {\n            result[field.name][locale] = localizedBlocks.map((row) => {\n              const block =\n                adapter.payload.blocks[row.blockType] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (block) => typeof block !== 'string' && block.slug === row.blockType,\n                ) as FlattenedBlock | undefined)\n\n              const tableName = adapter.tableNameMap.get(\n                `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n              )\n\n              if (block) {\n                const blockResult = traverseFields<T>({\n                  adapter,\n                  blocks,\n                  config,\n                  currentTableName: tableName,\n                  dataRef: row,\n                  deletions,\n                  fieldPrefix: '',\n                  fields: block.flattenedFields,\n                  numbers,\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  path: `${blockFieldPath}.${row._order - 1}`,\n                  relationships,\n                  table: row,\n                  tablePath: '',\n                  texts,\n                  topLevelTableName,\n                  withinArrayOrBlockLocale: locale,\n                })\n\n                delete blockResult._order\n                return blockResult\n              }\n\n              return {}\n            })\n          })\n        } else {\n          // Add locale-specific index to have a proper blockFieldPath for current locale\n          // because blocks can be in the same array for different locales!\n          if (withinArrayOrBlockLocale && config.localization) {\n            for (const locale of config.localization.localeCodes) {\n              let localeIndex = 0\n\n              for (let i = 0; i < blocksByPath.length; i++) {\n                const row = blocksByPath[i]\n                if (row._locale === locale) {\n                  row._index = localeIndex\n                  localeIndex++\n                }\n              }\n            }\n          }\n\n          result[field.name] = blocksByPath.reduce((acc, row, i) => {\n            delete row._order\n            if (row._uuid) {\n              row.id = row._uuid\n              delete row._uuid\n            }\n\n            if (typeof row.blockType !== 'string') {\n              return acc\n            }\n\n            const block =\n              adapter.payload.blocks[row.blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === row.blockType,\n              ) as FlattenedBlock | undefined)\n\n            if (block) {\n              if (\n                !withinArrayOrBlockLocale ||\n                (withinArrayOrBlockLocale && withinArrayOrBlockLocale === row._locale)\n              ) {\n                if (row._locale) {\n                  delete row._locale\n                }\n                if (typeof row._index === 'number') {\n                  i = row._index\n                  delete row._index\n                }\n\n                const tableName = adapter.tableNameMap.get(\n                  `${topLevelTableName}_blocks_${toSnakeCase(block.slug)}`,\n                )\n\n                acc.push(\n                  traverseFields<T>({\n                    adapter,\n                    blocks,\n                    config,\n                    currentTableName: tableName,\n                    dataRef: row,\n                    deletions,\n                    fieldPrefix: '',\n                    fields: block.flattenedFields,\n                    numbers,\n                    parentIsLocalized: parentIsLocalized || field.localized,\n                    path: `${blockFieldPath}.${i}`,\n                    relationships,\n                    table: row,\n                    tablePath: '',\n                    texts,\n                    topLevelTableName,\n                    withinArrayOrBlockLocale,\n                  }),\n                )\n\n                return acc\n              }\n            } else {\n              acc.push({})\n            }\n\n            return acc\n          }, [])\n        }\n      }\n\n      return result\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload') {\n      if (typeof field.relationTo === 'string' && !('hasMany' in field && field.hasMany)) {\n        if (\n          isLocalized &&\n          config.localization &&\n          config.localization.locales &&\n          Array.isArray(table?._locales)\n        ) {\n          table._locales.forEach((localeRow) => {\n            result[field.name] = { [localeRow._locale]: localeRow[fieldName] }\n          })\n        } else {\n          valuesToTransform.push({ ref: result, table })\n        }\n      } else {\n        const relationPathMatch = relationships[`${sanitizedPath}${field.name}`]\n\n        if (!relationPathMatch) {\n          if ('hasMany' in field && field.hasMany) {\n            if (isLocalized && config.localization && config.localization.locales) {\n              result[field.name] = {\n                [config.localization.defaultLocale]: [],\n              }\n            } else {\n              result[field.name] = []\n            }\n          }\n\n          return result\n        }\n\n        if (isLocalized) {\n          result[field.name] = {}\n          const relationsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n          relationPathMatch.forEach((row) => {\n            if (typeof row.locale === 'string') {\n              if (!relationsByLocale[row.locale]) {\n                relationsByLocale[row.locale] = []\n              }\n              relationsByLocale[row.locale].push(row)\n            }\n          })\n\n          Object.entries(relationsByLocale).forEach(([locale, relations]) => {\n            transformRelationship({\n              field,\n              locale,\n              ref: result,\n              relations,\n            })\n          })\n        } else {\n          transformRelationship({\n            field,\n            ref: result,\n            relations: relationPathMatch,\n            withinArrayOrBlockLocale,\n          })\n        }\n        return result\n      }\n    }\n\n    if (field.type === 'join') {\n      const { count, limit = field.defaultLimit ?? 10 } =\n        joinQuery?.[`${fieldPrefix.replaceAll('_', '.')}${field.name}`] || {}\n\n      // raw hasMany results from SQLite\n      if (typeof fieldData === 'string') {\n        fieldData = JSON.parse(fieldData)\n      }\n\n      let fieldResult:\n        | { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }\n        | Record<string, { docs: unknown[]; hasNextPage: boolean; totalDocs?: number }>\n      if (Array.isArray(fieldData)) {\n        if (isLocalized && adapter.payload.config.localization) {\n          fieldResult = fieldData.reduce(\n            (joinResult, row) => {\n              if (typeof row.locale === 'string') {\n                joinResult[row.locale].docs.push(row.id)\n              }\n\n              return joinResult\n            },\n\n            // initialize with defaults so empty won't be undefined\n            adapter.payload.config.localization.localeCodes.reduce((acc, code) => {\n              acc[code] = {\n                docs: [],\n                hasNextPage: false,\n              }\n              return acc\n            }, {}),\n          )\n          Object.keys(fieldResult).forEach((locale) => {\n            fieldResult[locale].hasNextPage = fieldResult[locale].docs.length > limit\n            fieldResult[locale].docs = fieldResult[locale].docs.slice(0, limit)\n          })\n        } else {\n          const hasNextPage = limit !== 0 && fieldData.length > limit\n          fieldResult = {\n            docs: (hasNextPage ? fieldData.slice(0, limit) : fieldData).map(\n              ({ id, relationTo }) => {\n                if (relationTo) {\n                  return { relationTo, value: id }\n                }\n                return { id }\n              },\n            ),\n            hasNextPage,\n          }\n        }\n      }\n\n      if (count) {\n        const countPath = `${fieldName}_count`\n        if (typeof table[countPath] !== 'undefined') {\n          let value = Number(table[countPath])\n          if (Number.isNaN(value)) {\n            value = 0\n          }\n          fieldResult.totalDocs = value\n        }\n      }\n\n      result[field.name] = fieldResult\n      return result\n    }\n\n    if (field.type === 'text' && field?.hasMany) {\n      const textPathMatch = texts[`${sanitizedPath}${field.name}`]\n      if (!textPathMatch) {\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const textsByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        textPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!textsByLocale[row.locale]) {\n              textsByLocale[row.locale] = []\n            }\n            textsByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(textsByLocale).forEach(([locale, texts]) => {\n          transformHasManyText({\n            field,\n            locale,\n            ref: result,\n            textRows: texts,\n          })\n        })\n      } else {\n        transformHasManyText({\n          field,\n          ref: result,\n          textRows: textPathMatch,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'number' && field.hasMany) {\n      const numberPathMatch = numbers[`${sanitizedPath}${field.name}`]\n      if (!numberPathMatch) {\n        return result\n      }\n\n      if (isLocalized) {\n        result[field.name] = {}\n        const numbersByLocale: Record<string, Record<string, unknown>[]> = {}\n\n        numberPathMatch.forEach((row) => {\n          if (typeof row.locale === 'string') {\n            if (!numbersByLocale[row.locale]) {\n              numbersByLocale[row.locale] = []\n            }\n            numbersByLocale[row.locale].push(row)\n          }\n        })\n\n        Object.entries(numbersByLocale).forEach(([locale, numbers]) => {\n          transformHasManyNumber({\n            field,\n            locale,\n            numberRows: numbers,\n            ref: result,\n          })\n        })\n      } else {\n        transformHasManyNumber({\n          field,\n          numberRows: numberPathMatch,\n          ref: result,\n          withinArrayOrBlockLocale,\n        })\n      }\n\n      return result\n    }\n\n    if (field.type === 'select' && field.hasMany) {\n      if (Array.isArray(fieldData)) {\n        if (isLocalized) {\n          result[field.name] = fieldData.reduce((selectResult, row) => {\n            if (typeof row.locale === 'string') {\n              if (!selectResult[row.locale]) {\n                selectResult[row.locale] = []\n              }\n              selectResult[row.locale].push(row.value)\n            }\n\n            return selectResult\n          }, {})\n        } else {\n          let selectData = fieldData\n          if (withinArrayOrBlockLocale) {\n            selectData = selectData.filter(({ locale }) => locale === withinArrayOrBlockLocale)\n          }\n          result[field.name] = selectData.map(({ value }) => value)\n        }\n      }\n      return result\n    }\n\n    if (isLocalized && Array.isArray(table._locales)) {\n      if (!table._locales.length && adapter.payload.config.localization) {\n        adapter.payload.config.localization.localeCodes.forEach((_locale) =>\n          (table._locales as unknown[]).push({ _locale }),\n        )\n      }\n\n      table._locales.forEach((localeRow) => {\n        valuesToTransform.push({\n          ref: localizedFieldData,\n          table: {\n            ...table,\n            ...localeRow,\n          },\n        })\n      })\n    } else {\n      valuesToTransform.push({ ref: result, table })\n    }\n\n    valuesToTransform.forEach(({ ref, table }) => {\n      const fieldData = table[`${fieldPrefix || ''}${field.name}`]\n      const locale = table?._locale\n      let val = fieldData\n\n      switch (field.type) {\n        case 'date': {\n          if (typeof fieldData === 'string') {\n            val = new Date(fieldData).toISOString()\n          }\n\n          break\n        }\n\n        case 'group':\n        case 'tab': {\n          const groupFieldPrefix = `${fieldPrefix || ''}${field.name}_`\n          const groupData = {}\n          const locale = table._locale as string\n          const refKey = isLocalized && locale ? locale : field.name\n\n          if (isLocalized && locale) {\n            delete table._locale\n          }\n          ref[refKey] = traverseFields<Record<string, unknown>>({\n            adapter,\n            blocks,\n            config,\n            currentTableName,\n            dataRef: groupData as Record<string, unknown>,\n            deletions,\n            fieldPrefix: groupFieldPrefix,\n            fields: field.flattenedFields,\n            joinQuery,\n            numbers,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            path: `${sanitizedPath}${field.name}`,\n            relationships,\n            table,\n            tablePath: `${tablePath}${toSnakeCase(field.name)}_`,\n            texts,\n            topLevelTableName,\n            withinArrayOrBlockLocale: locale || withinArrayOrBlockLocale,\n          })\n\n          if ('_order' in ref) {\n            delete ref._order\n          }\n\n          return\n        }\n\n        case 'number': {\n          if (typeof fieldData === 'string') {\n            val = Number.parseFloat(fieldData)\n          }\n\n          break\n        }\n\n        case 'point': {\n          if (typeof fieldData === 'string') {\n            val = JSON.parse(fieldData)\n          }\n\n          break\n        }\n\n        case 'relationship':\n        case 'upload': {\n          if (\n            val &&\n            typeof field.relationTo === 'string' &&\n            adapter.payload.collections[field.relationTo].customIDType === 'number'\n          ) {\n            val = Number(val)\n          }\n\n          break\n        }\n        case 'text': {\n          if (typeof fieldData === 'string') {\n            val = String(fieldData)\n          }\n\n          break\n        }\n\n        default: {\n          break\n        }\n      }\n      if (typeof locale === 'string') {\n        ref[locale] = val\n      } else {\n        result[field.name] = val\n      }\n    })\n\n    if (Object.keys(localizedFieldData).length > 0) {\n      result[field.name] = localizedFieldData\n    }\n\n    return result\n\n    return result\n  }, dataRef)\n\n  if (Array.isArray(table._locales)) {\n    deletions.push(() => delete table._locales)\n  }\n\n  return formatted as T\n}\n"],"names":["fieldIsVirtual","fieldShouldBeLocalized","toSnakeCase","transformHasManyNumber","transformHasManyText","transformRelationship","traverseFields","adapter","blocks","config","currentTableName","dataRef","deletions","fieldPrefix","fields","joinQuery","numbers","parentIsLocalized","path","relationships","table","tablePath","texts","topLevelTableName","withinArrayOrBlockLocale","sanitizedPath","formatted","reduce","result","field","fieldName","name","fieldData","localizedFieldData","valuesToTransform","push","isLocalized","type","arrayTableName","tableNameMap","get","dbName","Array","isArray","arrayResult","row","_locale","locale","data","_uuid","id","rowResult","flattenedFields","localized","_order","acc","i","blockFieldPath","blocksByPath","forEach","Object","entries","localizedBlocks","map","block","payload","blockType","blockReferences","find","slug","tableName","blockResult","localization","localeCodes","localeIndex","length","_index","relationTo","hasMany","locales","_locales","localeRow","ref","relationPathMatch","defaultLocale","relationsByLocale","relations","count","limit","defaultLimit","replaceAll","JSON","parse","fieldResult","joinResult","docs","code","hasNextPage","keys","slice","value","countPath","Number","isNaN","totalDocs","textPathMatch","textsByLocale","textRows","numberPathMatch","numbersByLocale","numberRows","selectResult","selectData","filter","val","Date","toISOString","groupFieldPrefix","groupData","refKey","parseFloat","collections","customIDType","String"],"mappings":"AAEA,SAASA,cAAc,EAAEC,sBAAsB,QAAQ,iBAAgB;AACvE,OAAOC,iBAAiB,gBAAe;AAKvC,SAASC,sBAAsB,QAAQ,qBAAoB;AAC3D,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,oBAAmB;AAiEzD,iDAAiD;AACjD,kDAAkD;AAClD,OAAO,MAAMC,iBAAiB,CAAoC,EAChEC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,gBAAgB,EAChBC,OAAO,EACPC,SAAS,EACTC,WAAW,EACXC,MAAM,EACNC,SAAS,EACTC,OAAO,EACPC,iBAAiB,EACjBC,IAAI,EACJC,aAAa,EACbC,KAAK,EACLC,SAAS,EACTC,KAAK,EACLC,iBAAiB,EACjBC,wBAAwB,EACL;IACnB,MAAMC,gBAAgBP,OAAO,GAAGA,KAAK,CAAC,CAAC,GAAGA;IAE1C,MAAMQ,YAAYZ,OAAOa,MAAM,CAAC,CAACC,QAAQC;QACvC,IAAI7B,eAAe6B,QAAQ;YACzB,OAAOD;QACT;QAEA,MAAME,YAAY,GAAGjB,eAAe,KAAKgB,MAAME,IAAI,EAAE;QACrD,IAAIC,YAAYZ,KAAK,CAACU,UAAU;QAChC,MAAMG,qBAAqB,CAAC;QAC5B,MAAMC,oBAGA,EAAE;QAER,IAAIrB,aAAa;YACfD,UAAUuB,IAAI,CAAC,IAAM,OAAOf,KAAK,CAACU,UAAU;QAC9C;QAEA,MAAMM,cAAcnC,uBAAuB;YAAE4B;YAAOZ;QAAkB;QAEtE,IAAIY,MAAMQ,IAAI,KAAK,SAAS;YAC1B,MAAMC,iBAAiB/B,QAAQgC,YAAY,CAACC,GAAG,CAC7C,GAAG9B,iBAAiB,CAAC,EAAEW,YAAYnB,YAAY2B,MAAME,IAAI,GAAG;YAG9D,IAAIF,MAAMY,MAAM,EAAE;gBAChBT,YAAYZ,KAAK,CAAC,CAAC,CAAC,EAAEkB,gBAAgB,CAAC;YACzC;YAEA,IAAII,MAAMC,OAAO,CAACX,YAAY;gBAC5B,IAAII,aAAa;oBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGC,UAAUL,MAAM,CAAC,CAACiB,aAAaC;wBAClD,IAAI,OAAOA,IAAIC,OAAO,KAAK,UAAU;4BACnC,IAAI,CAACF,WAAW,CAACC,IAAIC,OAAO,CAAC,EAAE;gCAC7BF,WAAW,CAACC,IAAIC,OAAO,CAAC,GAAG,EAAE;4BAC/B;4BACA,MAAMC,SAASF,IAAIC,OAAO;4BAC1B,MAAME,OAAO,CAAC;4BACd,OAAOH,IAAIC,OAAO;4BAClB,IAAID,IAAII,KAAK,EAAE;gCACbJ,IAAIK,EAAE,GAAGL,IAAII,KAAK;gCAClB,OAAOJ,IAAII,KAAK;4BAClB;4BAEA,MAAME,YAAY7C,eAAkB;gCAClCC;gCACAC;gCACAC;gCACAC,kBAAkB4B;gCAClB3B,SAASqC;gCACTpC;gCACAC,aAAa;gCACbC,QAAQe,MAAMuB,eAAe;gCAC7BpC;gCACAC,mBAAmBA,qBAAqBY,MAAMwB,SAAS;gCACvDnC,MAAM,GAAGO,gBAAgBI,MAAME,IAAI,CAAC,CAAC,EAAEc,IAAIS,MAAM,GAAG,GAAG;gCACvDnC;gCACAC,OAAOyB;gCACPxB,WAAW;gCACXC;gCACAC;gCACAC,0BAA0BuB;4BAC5B;4BAEA,IAAI,YAAYI,WAAW;gCACzB,OAAOA,UAAUG,MAAM;4BACzB;4BAEAV,WAAW,CAACG,OAAO,CAACZ,IAAI,CAACgB;wBAC3B;wBAEA,OAAOP;oBACT,GAAG,CAAC;gBACN,OAAO;oBACLhB,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGC,UAAUL,MAAM,CAAC,CAAC4B,KAAKV,KAAKW;wBAC/C,IAAIX,IAAII,KAAK,EAAE;4BACbJ,IAAIK,EAAE,GAAGL,IAAII,KAAK;4BAClB,OAAOJ,IAAII,KAAK;wBAClB;wBAEA,IAAI,YAAYJ,KAAK;4BACnB,OAAOA,IAAIS,MAAM;wBACnB;wBAEA,IACE,CAAC9B,4BACAA,4BAA4BA,6BAA6BqB,IAAIC,OAAO,EACrE;4BACA,IAAID,IAAIC,OAAO,EAAE;gCACf,OAAOD,IAAIC,OAAO;4BACpB;4BAEAS,IAAIpB,IAAI,CACN7B,eAAkB;gCAChBC;gCACAC;gCACAC;gCACAC,kBAAkB4B;gCAClB3B,SAASkC;gCACTjC;gCACAC,aAAa;gCACbC,QAAQe,MAAMuB,eAAe;gCAC7BpC;gCACAC,mBAAmBA,qBAAqBY,MAAMwB,SAAS;gCACvDnC,MAAM,GAAGO,gBAAgBI,MAAME,IAAI,CAAC,CAAC,EAAEyB,GAAG;gCAC1CrC;gCACAC,OAAOyB;gCACPxB,WAAW;gCACXC;gCACAC;gCACAC;4BACF;wBAEJ;wBAEA,OAAO+B;oBACT,GAAG,EAAE;gBACP;YACF;YAEA,OAAO3B;QACT;QAEA,IAAIC,MAAMQ,IAAI,KAAK,UAAU;YAC3B,MAAMoB,iBAAiB,GAAGhC,gBAAgBI,MAAME,IAAI,EAAE;YACtD,MAAM2B,eAAelD,MAAM,CAACiD,eAAe;YAE3C,IAAIf,MAAMC,OAAO,CAACe,eAAe;gBAC/B,IAAItB,aAAa;oBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG,CAAC;oBAEtB2B,aAAaC,OAAO,CAAC,CAACd;wBACpB,IAAIA,IAAII,KAAK,EAAE;4BACbJ,IAAIK,EAAE,GAAGL,IAAII,KAAK;4BAClB,OAAOJ,IAAII,KAAK;wBAClB;wBACA,IAAI,OAAOJ,IAAIC,OAAO,KAAK,UAAU;4BACnC,IAAI,CAAClB,MAAM,CAACC,MAAME,IAAI,CAAC,CAACc,IAAIC,OAAO,CAAC,EAAE;gCACpClB,MAAM,CAACC,MAAME,IAAI,CAAC,CAACc,IAAIC,OAAO,CAAC,GAAG,EAAE;4BACtC;4BACAlB,MAAM,CAACC,MAAME,IAAI,CAAC,CAACc,IAAIC,OAAO,CAAC,CAACX,IAAI,CAACU;4BACrC,OAAOA,IAAIC,OAAO;wBACpB;oBACF;oBAEAc,OAAOC,OAAO,CAACjC,MAAM,CAACC,MAAME,IAAI,CAAC,EAAE4B,OAAO,CAAC,CAAC,CAACZ,QAAQe,gBAAgB;wBACnElC,MAAM,CAACC,MAAME,IAAI,CAAC,CAACgB,OAAO,GAAGe,gBAAgBC,GAAG,CAAC,CAAClB;4BAChD,MAAMmB,QACJzD,QAAQ0D,OAAO,CAACzD,MAAM,CAACqC,IAAIqB,SAAS,CAAC,IACpC,AAACrC,CAAAA,MAAMsC,eAAe,IAAItC,MAAMrB,MAAM,AAAD,EAAG4D,IAAI,CAC3C,CAACJ,QAAU,OAAOA,UAAU,YAAYA,MAAMK,IAAI,KAAKxB,IAAIqB,SAAS;4BAGxE,MAAMI,YAAY/D,QAAQgC,YAAY,CAACC,GAAG,CACxC,GAAGjB,kBAAkB,QAAQ,EAAErB,YAAY8D,MAAMK,IAAI,GAAG;4BAG1D,IAAIL,OAAO;gCACT,MAAMO,cAAcjE,eAAkB;oCACpCC;oCACAC;oCACAC;oCACAC,kBAAkB4D;oCAClB3D,SAASkC;oCACTjC;oCACAC,aAAa;oCACbC,QAAQkD,MAAMZ,eAAe;oCAC7BpC;oCACAC,mBAAmBA,qBAAqBY,MAAMwB,SAAS;oCACvDnC,MAAM,GAAGuC,eAAe,CAAC,EAAEZ,IAAIS,MAAM,GAAG,GAAG;oCAC3CnC;oCACAC,OAAOyB;oCACPxB,WAAW;oCACXC;oCACAC;oCACAC,0BAA0BuB;gCAC5B;gCAEA,OAAOwB,YAAYjB,MAAM;gCACzB,OAAOiB;4BACT;4BAEA,OAAO,CAAC;wBACV;oBACF;gBACF,OAAO;oBACL,+EAA+E;oBAC/E,iEAAiE;oBACjE,IAAI/C,4BAA4Bf,OAAO+D,YAAY,EAAE;wBACnD,KAAK,MAAMzB,UAAUtC,OAAO+D,YAAY,CAACC,WAAW,CAAE;4BACpD,IAAIC,cAAc;4BAElB,IAAK,IAAIlB,IAAI,GAAGA,IAAIE,aAAaiB,MAAM,EAAEnB,IAAK;gCAC5C,MAAMX,MAAMa,YAAY,CAACF,EAAE;gCAC3B,IAAIX,IAAIC,OAAO,KAAKC,QAAQ;oCAC1BF,IAAI+B,MAAM,GAAGF;oCACbA;gCACF;4BACF;wBACF;oBACF;oBAEA9C,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG2B,aAAa/B,MAAM,CAAC,CAAC4B,KAAKV,KAAKW;wBAClD,OAAOX,IAAIS,MAAM;wBACjB,IAAIT,IAAII,KAAK,EAAE;4BACbJ,IAAIK,EAAE,GAAGL,IAAII,KAAK;4BAClB,OAAOJ,IAAII,KAAK;wBAClB;wBAEA,IAAI,OAAOJ,IAAIqB,SAAS,KAAK,UAAU;4BACrC,OAAOX;wBACT;wBAEA,MAAMS,QACJzD,QAAQ0D,OAAO,CAACzD,MAAM,CAACqC,IAAIqB,SAAS,CAAC,IACpC,AAACrC,CAAAA,MAAMsC,eAAe,IAAItC,MAAMrB,MAAM,AAAD,EAAG4D,IAAI,CAC3C,CAACJ,QAAU,OAAOA,UAAU,YAAYA,MAAMK,IAAI,KAAKxB,IAAIqB,SAAS;wBAGxE,IAAIF,OAAO;4BACT,IACE,CAACxC,4BACAA,4BAA4BA,6BAA6BqB,IAAIC,OAAO,EACrE;gCACA,IAAID,IAAIC,OAAO,EAAE;oCACf,OAAOD,IAAIC,OAAO;gCACpB;gCACA,IAAI,OAAOD,IAAI+B,MAAM,KAAK,UAAU;oCAClCpB,IAAIX,IAAI+B,MAAM;oCACd,OAAO/B,IAAI+B,MAAM;gCACnB;gCAEA,MAAMN,YAAY/D,QAAQgC,YAAY,CAACC,GAAG,CACxC,GAAGjB,kBAAkB,QAAQ,EAAErB,YAAY8D,MAAMK,IAAI,GAAG;gCAG1Dd,IAAIpB,IAAI,CACN7B,eAAkB;oCAChBC;oCACAC;oCACAC;oCACAC,kBAAkB4D;oCAClB3D,SAASkC;oCACTjC;oCACAC,aAAa;oCACbC,QAAQkD,MAAMZ,eAAe;oCAC7BpC;oCACAC,mBAAmBA,qBAAqBY,MAAMwB,SAAS;oCACvDnC,MAAM,GAAGuC,eAAe,CAAC,EAAED,GAAG;oCAC9BrC;oCACAC,OAAOyB;oCACPxB,WAAW;oCACXC;oCACAC;oCACAC;gCACF;gCAGF,OAAO+B;4BACT;wBACF,OAAO;4BACLA,IAAIpB,IAAI,CAAC,CAAC;wBACZ;wBAEA,OAAOoB;oBACT,GAAG,EAAE;gBACP;YACF;YAEA,OAAO3B;QACT;QAEA,IAAIC,MAAMQ,IAAI,KAAK,kBAAkBR,MAAMQ,IAAI,KAAK,UAAU;YAC5D,IAAI,OAAOR,MAAMgD,UAAU,KAAK,YAAY,CAAE,CAAA,aAAahD,SAASA,MAAMiD,OAAO,AAAD,GAAI;gBAClF,IACE1C,eACA3B,OAAO+D,YAAY,IACnB/D,OAAO+D,YAAY,CAACO,OAAO,IAC3BrC,MAAMC,OAAO,CAACvB,OAAO4D,WACrB;oBACA5D,MAAM4D,QAAQ,CAACrB,OAAO,CAAC,CAACsB;wBACtBrD,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG;4BAAE,CAACkD,UAAUnC,OAAO,CAAC,EAAEmC,SAAS,CAACnD,UAAU;wBAAC;oBACnE;gBACF,OAAO;oBACLI,kBAAkBC,IAAI,CAAC;wBAAE+C,KAAKtD;wBAAQR;oBAAM;gBAC9C;YACF,OAAO;gBACL,MAAM+D,oBAAoBhE,aAAa,CAAC,GAAGM,gBAAgBI,MAAME,IAAI,EAAE,CAAC;gBAExE,IAAI,CAACoD,mBAAmB;oBACtB,IAAI,aAAatD,SAASA,MAAMiD,OAAO,EAAE;wBACvC,IAAI1C,eAAe3B,OAAO+D,YAAY,IAAI/D,OAAO+D,YAAY,CAACO,OAAO,EAAE;4BACrEnD,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG;gCACnB,CAACtB,OAAO+D,YAAY,CAACY,aAAa,CAAC,EAAE,EAAE;4BACzC;wBACF,OAAO;4BACLxD,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG,EAAE;wBACzB;oBACF;oBAEA,OAAOH;gBACT;gBAEA,IAAIQ,aAAa;oBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG,CAAC;oBACtB,MAAMsD,oBAA+D,CAAC;oBAEtEF,kBAAkBxB,OAAO,CAAC,CAACd;wBACzB,IAAI,OAAOA,IAAIE,MAAM,KAAK,UAAU;4BAClC,IAAI,CAACsC,iBAAiB,CAACxC,IAAIE,MAAM,CAAC,EAAE;gCAClCsC,iBAAiB,CAACxC,IAAIE,MAAM,CAAC,GAAG,EAAE;4BACpC;4BACAsC,iBAAiB,CAACxC,IAAIE,MAAM,CAAC,CAACZ,IAAI,CAACU;wBACrC;oBACF;oBAEAe,OAAOC,OAAO,CAACwB,mBAAmB1B,OAAO,CAAC,CAAC,CAACZ,QAAQuC,UAAU;wBAC5DjF,sBAAsB;4BACpBwB;4BACAkB;4BACAmC,KAAKtD;4BACL0D;wBACF;oBACF;gBACF,OAAO;oBACLjF,sBAAsB;wBACpBwB;wBACAqD,KAAKtD;wBACL0D,WAAWH;wBACX3D;oBACF;gBACF;gBACA,OAAOI;YACT;QACF;QAEA,IAAIC,MAAMQ,IAAI,KAAK,QAAQ;YACzB,MAAM,EAAEkD,KAAK,EAAEC,QAAQ3D,MAAM4D,YAAY,IAAI,EAAE,EAAE,GAC/C1E,WAAW,CAAC,GAAGF,YAAY6E,UAAU,CAAC,KAAK,OAAO7D,MAAME,IAAI,EAAE,CAAC,IAAI,CAAC;YAEtE,kCAAkC;YAClC,IAAI,OAAOC,cAAc,UAAU;gBACjCA,YAAY2D,KAAKC,KAAK,CAAC5D;YACzB;YAEA,IAAI6D;YAGJ,IAAInD,MAAMC,OAAO,CAACX,YAAY;gBAC5B,IAAII,eAAe7B,QAAQ0D,OAAO,CAACxD,MAAM,CAAC+D,YAAY,EAAE;oBACtDqB,cAAc7D,UAAUL,MAAM,CAC5B,CAACmE,YAAYjD;wBACX,IAAI,OAAOA,IAAIE,MAAM,KAAK,UAAU;4BAClC+C,UAAU,CAACjD,IAAIE,MAAM,CAAC,CAACgD,IAAI,CAAC5D,IAAI,CAACU,IAAIK,EAAE;wBACzC;wBAEA,OAAO4C;oBACT,GAEA,uDAAuD;oBACvDvF,QAAQ0D,OAAO,CAACxD,MAAM,CAAC+D,YAAY,CAACC,WAAW,CAAC9C,MAAM,CAAC,CAAC4B,KAAKyC;wBAC3DzC,GAAG,CAACyC,KAAK,GAAG;4BACVD,MAAM,EAAE;4BACRE,aAAa;wBACf;wBACA,OAAO1C;oBACT,GAAG,CAAC;oBAENK,OAAOsC,IAAI,CAACL,aAAalC,OAAO,CAAC,CAACZ;wBAChC8C,WAAW,CAAC9C,OAAO,CAACkD,WAAW,GAAGJ,WAAW,CAAC9C,OAAO,CAACgD,IAAI,CAACpB,MAAM,GAAGa;wBACpEK,WAAW,CAAC9C,OAAO,CAACgD,IAAI,GAAGF,WAAW,CAAC9C,OAAO,CAACgD,IAAI,CAACI,KAAK,CAAC,GAAGX;oBAC/D;gBACF,OAAO;oBACL,MAAMS,cAAcT,UAAU,KAAKxD,UAAU2C,MAAM,GAAGa;oBACtDK,cAAc;wBACZE,MAAM,AAACE,CAAAA,cAAcjE,UAAUmE,KAAK,CAAC,GAAGX,SAASxD,SAAQ,EAAG+B,GAAG,CAC7D,CAAC,EAAEb,EAAE,EAAE2B,UAAU,EAAE;4BACjB,IAAIA,YAAY;gCACd,OAAO;oCAAEA;oCAAYuB,OAAOlD;gCAAG;4BACjC;4BACA,OAAO;gCAAEA;4BAAG;wBACd;wBAEF+C;oBACF;gBACF;YACF;YAEA,IAAIV,OAAO;gBACT,MAAMc,YAAY,GAAGvE,UAAU,MAAM,CAAC;gBACtC,IAAI,OAAOV,KAAK,CAACiF,UAAU,KAAK,aAAa;oBAC3C,IAAID,QAAQE,OAAOlF,KAAK,CAACiF,UAAU;oBACnC,IAAIC,OAAOC,KAAK,CAACH,QAAQ;wBACvBA,QAAQ;oBACV;oBACAP,YAAYW,SAAS,GAAGJ;gBAC1B;YACF;YAEAxE,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG8D;YACrB,OAAOjE;QACT;QAEA,IAAIC,MAAMQ,IAAI,KAAK,UAAUR,OAAOiD,SAAS;YAC3C,MAAM2B,gBAAgBnF,KAAK,CAAC,GAAGG,gBAAgBI,MAAME,IAAI,EAAE,CAAC;YAC5D,IAAI,CAAC0E,eAAe;gBAClB,OAAO7E;YACT;YAEA,IAAIQ,aAAa;gBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG,CAAC;gBACtB,MAAM2E,gBAA2D,CAAC;gBAElED,cAAc9C,OAAO,CAAC,CAACd;oBACrB,IAAI,OAAOA,IAAIE,MAAM,KAAK,UAAU;wBAClC,IAAI,CAAC2D,aAAa,CAAC7D,IAAIE,MAAM,CAAC,EAAE;4BAC9B2D,aAAa,CAAC7D,IAAIE,MAAM,CAAC,GAAG,EAAE;wBAChC;wBACA2D,aAAa,CAAC7D,IAAIE,MAAM,CAAC,CAACZ,IAAI,CAACU;oBACjC;gBACF;gBAEAe,OAAOC,OAAO,CAAC6C,eAAe/C,OAAO,CAAC,CAAC,CAACZ,QAAQzB,MAAM;oBACpDlB,qBAAqB;wBACnByB;wBACAkB;wBACAmC,KAAKtD;wBACL+E,UAAUrF;oBACZ;gBACF;YACF,OAAO;gBACLlB,qBAAqB;oBACnByB;oBACAqD,KAAKtD;oBACL+E,UAAUF;oBACVjF;gBACF;YACF;YAEA,OAAOI;QACT;QAEA,IAAIC,MAAMQ,IAAI,KAAK,YAAYR,MAAMiD,OAAO,EAAE;YAC5C,MAAM8B,kBAAkB5F,OAAO,CAAC,GAAGS,gBAAgBI,MAAME,IAAI,EAAE,CAAC;YAChE,IAAI,CAAC6E,iBAAiB;gBACpB,OAAOhF;YACT;YAEA,IAAIQ,aAAa;gBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAG,CAAC;gBACtB,MAAM8E,kBAA6D,CAAC;gBAEpED,gBAAgBjD,OAAO,CAAC,CAACd;oBACvB,IAAI,OAAOA,IAAIE,MAAM,KAAK,UAAU;wBAClC,IAAI,CAAC8D,eAAe,CAAChE,IAAIE,MAAM,CAAC,EAAE;4BAChC8D,eAAe,CAAChE,IAAIE,MAAM,CAAC,GAAG,EAAE;wBAClC;wBACA8D,eAAe,CAAChE,IAAIE,MAAM,CAAC,CAACZ,IAAI,CAACU;oBACnC;gBACF;gBAEAe,OAAOC,OAAO,CAACgD,iBAAiBlD,OAAO,CAAC,CAAC,CAACZ,QAAQ/B,QAAQ;oBACxDb,uBAAuB;wBACrB0B;wBACAkB;wBACA+D,YAAY9F;wBACZkE,KAAKtD;oBACP;gBACF;YACF,OAAO;gBACLzB,uBAAuB;oBACrB0B;oBACAiF,YAAYF;oBACZ1B,KAAKtD;oBACLJ;gBACF;YACF;YAEA,OAAOI;QACT;QAEA,IAAIC,MAAMQ,IAAI,KAAK,YAAYR,MAAMiD,OAAO,EAAE;YAC5C,IAAIpC,MAAMC,OAAO,CAACX,YAAY;gBAC5B,IAAII,aAAa;oBACfR,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGC,UAAUL,MAAM,CAAC,CAACoF,cAAclE;wBACnD,IAAI,OAAOA,IAAIE,MAAM,KAAK,UAAU;4BAClC,IAAI,CAACgE,YAAY,CAAClE,IAAIE,MAAM,CAAC,EAAE;gCAC7BgE,YAAY,CAAClE,IAAIE,MAAM,CAAC,GAAG,EAAE;4BAC/B;4BACAgE,YAAY,CAAClE,IAAIE,MAAM,CAAC,CAACZ,IAAI,CAACU,IAAIuD,KAAK;wBACzC;wBAEA,OAAOW;oBACT,GAAG,CAAC;gBACN,OAAO;oBACL,IAAIC,aAAahF;oBACjB,IAAIR,0BAA0B;wBAC5BwF,aAAaA,WAAWC,MAAM,CAAC,CAAC,EAAElE,MAAM,EAAE,GAAKA,WAAWvB;oBAC5D;oBACAI,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGiF,WAAWjD,GAAG,CAAC,CAAC,EAAEqC,KAAK,EAAE,GAAKA;gBACrD;YACF;YACA,OAAOxE;QACT;QAEA,IAAIQ,eAAeM,MAAMC,OAAO,CAACvB,MAAM4D,QAAQ,GAAG;YAChD,IAAI,CAAC5D,MAAM4D,QAAQ,CAACL,MAAM,IAAIpE,QAAQ0D,OAAO,CAACxD,MAAM,CAAC+D,YAAY,EAAE;gBACjEjE,QAAQ0D,OAAO,CAACxD,MAAM,CAAC+D,YAAY,CAACC,WAAW,CAACd,OAAO,CAAC,CAACb,UACvD,AAAC1B,MAAM4D,QAAQ,CAAe7C,IAAI,CAAC;wBAAEW;oBAAQ;YAEjD;YAEA1B,MAAM4D,QAAQ,CAACrB,OAAO,CAAC,CAACsB;gBACtB/C,kBAAkBC,IAAI,CAAC;oBACrB+C,KAAKjD;oBACLb,OAAO;wBACL,GAAGA,KAAK;wBACR,GAAG6D,SAAS;oBACd;gBACF;YACF;QACF,OAAO;YACL/C,kBAAkBC,IAAI,CAAC;gBAAE+C,KAAKtD;gBAAQR;YAAM;QAC9C;QAEAc,kBAAkByB,OAAO,CAAC,CAAC,EAAEuB,GAAG,EAAE9D,KAAK,EAAE;YACvC,MAAMY,YAAYZ,KAAK,CAAC,GAAGP,eAAe,KAAKgB,MAAME,IAAI,EAAE,CAAC;YAC5D,MAAMgB,SAAS3B,OAAO0B;YACtB,IAAIoE,MAAMlF;YAEV,OAAQH,MAAMQ,IAAI;gBAChB,KAAK;oBAAQ;wBACX,IAAI,OAAOL,cAAc,UAAU;4BACjCkF,MAAM,IAAIC,KAAKnF,WAAWoF,WAAW;wBACvC;wBAEA;oBACF;gBAEA,KAAK;gBACL,KAAK;oBAAO;wBACV,MAAMC,mBAAmB,GAAGxG,eAAe,KAAKgB,MAAME,IAAI,CAAC,CAAC,CAAC;wBAC7D,MAAMuF,YAAY,CAAC;wBACnB,MAAMvE,SAAS3B,MAAM0B,OAAO;wBAC5B,MAAMyE,SAASnF,eAAeW,SAASA,SAASlB,MAAME,IAAI;wBAE1D,IAAIK,eAAeW,QAAQ;4BACzB,OAAO3B,MAAM0B,OAAO;wBACtB;wBACAoC,GAAG,CAACqC,OAAO,GAAGjH,eAAwC;4BACpDC;4BACAC;4BACAC;4BACAC;4BACAC,SAAS2G;4BACT1G;4BACAC,aAAawG;4BACbvG,QAAQe,MAAMuB,eAAe;4BAC7BrC;4BACAC;4BACAC,mBAAmBA,qBAAqBY,MAAMwB,SAAS;4BACvDnC,MAAM,GAAGO,gBAAgBI,MAAME,IAAI,EAAE;4BACrCZ;4BACAC;4BACAC,WAAW,GAAGA,YAAYnB,YAAY2B,MAAME,IAAI,EAAE,CAAC,CAAC;4BACpDT;4BACAC;4BACAC,0BAA0BuB,UAAUvB;wBACtC;wBAEA,IAAI,YAAY0D,KAAK;4BACnB,OAAOA,IAAI5B,MAAM;wBACnB;wBAEA;oBACF;gBAEA,KAAK;oBAAU;wBACb,IAAI,OAAOtB,cAAc,UAAU;4BACjCkF,MAAMZ,OAAOkB,UAAU,CAACxF;wBAC1B;wBAEA;oBACF;gBAEA,KAAK;oBAAS;wBACZ,IAAI,OAAOA,cAAc,UAAU;4BACjCkF,MAAMvB,KAAKC,KAAK,CAAC5D;wBACnB;wBAEA;oBACF;gBAEA,KAAK;gBACL,KAAK;oBAAU;wBACb,IACEkF,OACA,OAAOrF,MAAMgD,UAAU,KAAK,YAC5BtE,QAAQ0D,OAAO,CAACwD,WAAW,CAAC5F,MAAMgD,UAAU,CAAC,CAAC6C,YAAY,KAAK,UAC/D;4BACAR,MAAMZ,OAAOY;wBACf;wBAEA;oBACF;gBACA,KAAK;oBAAQ;wBACX,IAAI,OAAOlF,cAAc,UAAU;4BACjCkF,MAAMS,OAAO3F;wBACf;wBAEA;oBACF;gBAEA;oBAAS;wBACP;oBACF;YACF;YACA,IAAI,OAAOe,WAAW,UAAU;gBAC9BmC,GAAG,CAACnC,OAAO,GAAGmE;YAChB,OAAO;gBACLtF,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGmF;YACvB;QACF;QAEA,IAAItD,OAAOsC,IAAI,CAACjE,oBAAoB0C,MAAM,GAAG,GAAG;YAC9C/C,MAAM,CAACC,MAAME,IAAI,CAAC,GAAGE;QACvB;QAEA,OAAOL;QAEP,OAAOA;IACT,GAAGjB;IAEH,IAAI+B,MAAMC,OAAO,CAACvB,MAAM4D,QAAQ,GAAG;QACjCpE,UAAUuB,IAAI,CAAC,IAAM,OAAOf,MAAM4D,QAAQ;IAC5C;IAEA,OAAOtD;AACT,EAAC"}