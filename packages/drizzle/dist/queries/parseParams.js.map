{"version":3,"sources":["../../src/queries/parseParams.ts"],"sourcesContent":["import type { SQL, Table } from 'drizzle-orm'\nimport type { FlattenedField, Operator, Where } from 'payload'\n\nimport { and, isNotNull, isNull, ne, notInArray, or, sql } from 'drizzle-orm'\nimport { PgUUID } from 'drizzle-orm/pg-core'\nimport { QueryError } from 'payload'\nimport { validOperatorSet } from 'payload/shared'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { getNameFromDrizzleTable } from '../utilities/getNameFromDrizzleTable.js'\nimport { buildAndOrConditions } from './buildAndOrConditions.js'\nimport { getTableColumnFromPath } from './getTableColumnFromPath.js'\nimport { sanitizeQueryValue } from './sanitizeQueryValue.js'\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: Table\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  where: Where\n}\n\nexport function parseParams({\n  adapter,\n  aliasTable,\n  fields,\n  joins,\n  locale,\n  parentIsLocalized,\n  selectFields,\n  selectLocale,\n  tableName,\n  where,\n}: Args): SQL {\n  let result: SQL\n  const constraints: SQL[] = []\n\n  if (typeof where === 'object' && Object.keys(where).length > 0) {\n    // We need to determine if the whereKey is an AND, OR, or a schema path\n    for (const relationOrPath of Object.keys(where)) {\n      if (relationOrPath) {\n        const condition = where[relationOrPath]\n        let conditionOperator: typeof and | typeof or\n        if (relationOrPath.toLowerCase() === 'and') {\n          conditionOperator = and\n        } else if (relationOrPath.toLowerCase() === 'or') {\n          conditionOperator = or\n        }\n        if (Array.isArray(condition)) {\n          const builtConditions = buildAndOrConditions({\n            adapter,\n            aliasTable,\n            fields,\n            joins,\n            locale,\n            parentIsLocalized,\n            selectFields,\n            selectLocale,\n            tableName,\n            where: condition,\n          })\n          if (builtConditions.length > 0) {\n            result = conditionOperator(...builtConditions)\n          }\n        } else {\n          // It's a path - and there can be multiple comparisons on a single path.\n          // For example - title like 'test' and title not equal to 'tester'\n          // So we need to loop on keys again here to handle each operator independently\n          const pathOperators = where[relationOrPath]\n          if (typeof pathOperators === 'object') {\n            for (let operator of Object.keys(pathOperators)) {\n              if (validOperatorSet.has(operator as Operator)) {\n                const val = where[relationOrPath][operator]\n\n                const {\n                  columnName,\n                  columns,\n                  constraints: queryConstraints,\n                  field,\n                  getNotNullColumnByValue,\n                  pathSegments,\n                  rawColumn,\n                  table,\n                } = getTableColumnFromPath({\n                  adapter,\n                  aliasTable,\n                  collectionPath: relationOrPath,\n                  fields,\n                  joins,\n                  locale,\n                  parentIsLocalized,\n                  pathSegments: relationOrPath.replace(/__/g, '.').split('.'),\n                  selectFields,\n                  selectLocale,\n                  tableName,\n                  value: val,\n                })\n\n                queryConstraints.forEach(({ columnName: col, table: constraintTable, value }) => {\n                  if (typeof value === 'string' && value.indexOf('%') > -1) {\n                    constraints.push(adapter.operators.like(constraintTable[col], value))\n                  } else {\n                    constraints.push(adapter.operators.equals(constraintTable[col], value))\n                  }\n                })\n\n                if (\n                  ['json', 'richText'].includes(field.type) &&\n                  Array.isArray(pathSegments) &&\n                  pathSegments.length > 1\n                ) {\n                  if (adapter.name === 'postgres') {\n                    const constraint = adapter.createJSONQuery({\n                      column: rawColumn || table[columnName],\n                      operator,\n                      pathSegments,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(constraint))\n                    break\n                  }\n\n                  const segments = pathSegments.slice(1)\n                  segments.unshift(table[columnName].name)\n\n                  if (field.type === 'richText') {\n                    // use the table name from the nearest join to handle blocks, arrays, etc. or use the tableName arg\n                    const jsonTable =\n                      joins.length === 0\n                        ? tableName\n                        : joins[joins.length - 1].table[\n                            Object.getOwnPropertySymbols(joins[joins.length - 1].table)[0]\n                          ]\n                    const jsonQuery = adapter.createJSONQuery({\n                      operator,\n                      pathSegments: segments,\n                      table: jsonTable,\n                      treatAsArray: ['children'],\n                      treatRootAsArray: true,\n                      value: val,\n                    })\n\n                    constraints.push(sql.raw(jsonQuery))\n                    break\n                  }\n\n                  const jsonQuery = adapter.convertPathToJSONTraversal(pathSegments)\n                  const operatorKeys: Record<string, { operator: string; wildcard: string }> = {\n                    contains: { operator: 'like', wildcard: '%' },\n                    equals: { operator: '=', wildcard: '' },\n                    exists: { operator: val === true ? 'is not null' : 'is null', wildcard: '' },\n                    in: { operator: 'in', wildcard: '' },\n                    like: { operator: 'like', wildcard: '%' },\n                    not_equals: { operator: '<>', wildcard: '' },\n                    not_in: { operator: 'not in', wildcard: '' },\n                    not_like: { operator: 'not like', wildcard: '%' },\n                  }\n\n                  let formattedValue = val\n                  if (adapter.name === 'sqlite' && operator === 'equals' && !isNaN(val)) {\n                    formattedValue = val\n                  } else if (['in', 'not_in'].includes(operator) && Array.isArray(val)) {\n                    formattedValue = `(${val.map((v) => `${v}`).join(',')})`\n                  } else {\n                    formattedValue = `'${operatorKeys[operator].wildcard}${val}${operatorKeys[operator].wildcard}'`\n                  }\n                  if (operator === 'exists') {\n                    formattedValue = ''\n                  }\n\n                  let jsonQuerySelector = `${table[columnName].name}${jsonQuery}`\n\n                  if (adapter.name === 'sqlite' && operator === 'not_like') {\n                    jsonQuerySelector = `COALESCE(${table[columnName].name}${jsonQuery}, '')`\n                  }\n\n                  const rawSQLQuery = `${jsonQuerySelector} ${operatorKeys[operator].operator} ${formattedValue}`\n\n                  constraints.push(sql.raw(rawSQLQuery))\n\n                  break\n                }\n\n                if (getNotNullColumnByValue) {\n                  const columnName = getNotNullColumnByValue(val)\n                  if (columnName) {\n                    constraints.push(isNotNull(table[columnName]))\n                  } else {\n                    throw new QueryError([{ path: relationOrPath }])\n                  }\n                  break\n                }\n\n                if (\n                  operator === 'like' &&\n                  (field.type === 'number' || table[columnName].columnType === 'PgUUID')\n                ) {\n                  operator = 'equals'\n                }\n\n                if (operator === 'like') {\n                  constraints.push(\n                    and(\n                      ...val\n                        .split(' ')\n                        .map((word) => adapter.operators.like(table[columnName], `%${word}%`)),\n                    ),\n                  )\n                  break\n                }\n\n                const sanitizedQueryValue = sanitizeQueryValue({\n                  adapter,\n                  columns,\n                  field,\n                  isUUID: table?.[columnName] instanceof PgUUID,\n                  operator,\n                  relationOrPath,\n                  val,\n                })\n\n                if (sanitizedQueryValue === null) {\n                  break\n                }\n\n                const {\n                  columns: queryColumns,\n                  operator: queryOperator,\n                  value: queryValue,\n                } = sanitizedQueryValue\n\n                // Handle polymorphic relationships by value\n                if (queryColumns) {\n                  if (!queryColumns.length) {\n                    break\n                  }\n\n                  let wrapOperator = or\n\n                  if (queryValue === null && ['equals', 'not_equals'].includes(operator)) {\n                    if (operator === 'equals') {\n                      wrapOperator = and\n                    }\n\n                    constraints.push(\n                      wrapOperator(\n                        ...queryColumns.map(({ rawColumn }) =>\n                          operator === 'equals' ? isNull(rawColumn) : isNotNull(rawColumn),\n                        ),\n                      ),\n                    )\n                    break\n                  }\n\n                  if (['not_equals', 'not_in'].includes(operator)) {\n                    wrapOperator = and\n                  }\n\n                  constraints.push(\n                    wrapOperator(\n                      ...queryColumns.map(({ rawColumn, value }) =>\n                        adapter.operators[queryOperator](rawColumn, value),\n                      ),\n                    ),\n                  )\n\n                  break\n                }\n\n                const resolvedColumn =\n                  rawColumn ||\n                  (aliasTable && tableName === getNameFromDrizzleTable(table)\n                    ? aliasTable[columnName]\n                    : table[columnName])\n\n                if (queryOperator === 'not_equals' && queryValue !== null) {\n                  constraints.push(\n                    or(\n                      isNull(resolvedColumn),\n                      /* eslint-disable @typescript-eslint/no-explicit-any */\n                      ne<any>(resolvedColumn, queryValue),\n                    ),\n                  )\n                  break\n                }\n\n                if (\n                  (field.type === 'relationship' || field.type === 'upload') &&\n                  Array.isArray(queryValue) &&\n                  operator === 'not_in'\n                ) {\n                  constraints.push(\n                    sql`(${notInArray(table[columnName], queryValue)} OR\n                    ${table[columnName]}\n                    IS\n                    NULL)`,\n                  )\n\n                  break\n                }\n\n                if (operator === 'equals' && queryValue === null) {\n                  constraints.push(isNull(resolvedColumn))\n                  break\n                }\n\n                if (operator === 'not_equals' && queryValue === null) {\n                  constraints.push(isNotNull(resolvedColumn))\n                  break\n                }\n\n                if (field.type === 'point' && adapter.name === 'postgres') {\n                  switch (operator) {\n                    case 'intersects': {\n                      constraints.push(\n                        sql`ST_Intersects(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    case 'near': {\n                      const [lng, lat, maxDistance, minDistance] = queryValue as number[]\n                      const geoConstraints: SQL[] = []\n\n                      if (typeof maxDistance === 'number' && !Number.isNaN(maxDistance)) {\n                        geoConstraints.push(\n                          sql`ST_DWithin(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857), ${maxDistance})`,\n                        )\n                      }\n\n                      if (typeof minDistance === 'number' && !Number.isNaN(minDistance)) {\n                        geoConstraints.push(\n                          sql`ST_Distance(ST_Transform(${table[columnName]}, 3857), ST_Transform(ST_SetSRID(ST_MakePoint(${lng}, ${lat}), 4326), 3857)) >= ${minDistance}`,\n                        )\n                      }\n                      if (geoConstraints.length) {\n                        constraints.push(and(...geoConstraints))\n                      }\n                      break\n                    }\n\n                    case 'within': {\n                      constraints.push(\n                        sql`ST_Within(${table[columnName]}, ST_GeomFromGeoJSON(${JSON.stringify(queryValue)}))`,\n                      )\n                      break\n                    }\n\n                    default:\n                      break\n                  }\n                  break\n                }\n\n                constraints.push(adapter.operators[queryOperator](resolvedColumn, queryValue))\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (constraints.length > 0) {\n    if (result) {\n      result = and(result, ...constraints)\n    } else {\n      result = and(...constraints)\n    }\n  }\n  if (constraints.length === 1 && !result) {\n    ;[result] = constraints\n  }\n\n  return result\n}\n"],"names":["and","isNotNull","isNull","ne","notInArray","or","sql","PgUUID","QueryError","validOperatorSet","getNameFromDrizzleTable","buildAndOrConditions","getTableColumnFromPath","sanitizeQueryValue","parseParams","adapter","aliasTable","fields","joins","locale","parentIsLocalized","selectFields","selectLocale","tableName","where","result","constraints","Object","keys","length","relationOrPath","condition","conditionOperator","toLowerCase","Array","isArray","builtConditions","pathOperators","operator","has","val","columnName","columns","queryConstraints","field","getNotNullColumnByValue","pathSegments","rawColumn","table","collectionPath","replace","split","value","forEach","col","constraintTable","indexOf","push","operators","like","equals","includes","type","name","constraint","createJSONQuery","column","raw","segments","slice","unshift","jsonTable","getOwnPropertySymbols","jsonQuery","treatAsArray","treatRootAsArray","convertPathToJSONTraversal","operatorKeys","contains","wildcard","exists","in","not_equals","not_in","not_like","formattedValue","isNaN","map","v","join","jsonQuerySelector","rawSQLQuery","path","columnType","word","sanitizedQueryValue","isUUID","queryColumns","queryOperator","queryValue","wrapOperator","resolvedColumn","JSON","stringify","lng","lat","maxDistance","minDistance","geoConstraints","Number"],"mappings":"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"}