{"version":3,"sources":["../../src/queries/getTableColumnFromPath.ts"],"sourcesContent":["import type { SQL } from 'drizzle-orm'\nimport type { SQLiteTableWithColumns } from 'drizzle-orm/sqlite-core'\nimport type {\n  FlattenedBlock,\n  FlattenedField,\n  NumberField,\n  RelationshipField,\n  TextField,\n} from 'payload'\n\nimport { and, eq, like, sql } from 'drizzle-orm'\nimport { type PgTableWithColumns } from 'drizzle-orm/pg-core'\nimport { APIError, getFieldByPath } from 'payload'\nimport { fieldShouldBeLocalized, tabHasName } from 'payload/shared'\nimport toSnakeCase from 'to-snake-case'\nimport { validate as uuidValidate } from 'uuid'\n\nimport type { DrizzleAdapter, GenericColumn } from '../types.js'\nimport type { BuildQueryJoinAliases } from './buildQuery.js'\n\nimport { isPolymorphicRelationship } from '../utilities/isPolymorphicRelationship.js'\nimport { addJoinTable } from './addJoinTable.js'\nimport { getTableAlias } from './getTableAlias.js'\n\ntype Constraint = {\n  columnName: string\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  value: unknown\n}\n\ntype TableColumn = {\n  columnName?: string\n  columns?: {\n    idType: 'number' | 'text' | 'uuid'\n    rawColumn: SQL<unknown>\n  }[]\n  constraints: Constraint[]\n  field: FlattenedField\n  getNotNullColumnByValue?: (val: unknown) => string\n  pathSegments?: string[]\n  rawColumn?: SQL\n  table: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n}\n\ntype Args = {\n  adapter: DrizzleAdapter\n  aliasTable?: PgTableWithColumns<any> | SQLiteTableWithColumns<any>\n  collectionPath: string\n  columnPrefix?: string\n  constraintPath?: string\n  constraints?: Constraint[]\n  fields: FlattenedField[]\n  joins: BuildQueryJoinAliases\n  locale?: string\n  parentIsLocalized: boolean\n  pathSegments: string[]\n  rootTableName?: string\n  selectFields: Record<string, GenericColumn>\n  selectLocale?: boolean\n  tableName: string\n  /**\n   * If creating a new table name for arrays and blocks, this suffix should be appended to the table name\n   */\n  tableNameSuffix?: string\n  /**\n   * The raw value of the query before sanitization\n   */\n  value: unknown\n}\n/**\n * Transforms path to table and column name or to a list of OR columns\n * Adds tables to `join`\n * @returns TableColumn\n */\nexport const getTableColumnFromPath = ({\n  adapter,\n  aliasTable,\n  collectionPath,\n  columnPrefix = '',\n  constraintPath: incomingConstraintPath,\n  constraints = [],\n  fields,\n  joins,\n  locale: incomingLocale,\n  parentIsLocalized,\n  pathSegments: incomingSegments,\n  rootTableName: incomingRootTableName,\n  selectFields,\n  selectLocale,\n  tableName,\n  tableNameSuffix = '',\n  value,\n}: Args): TableColumn => {\n  const fieldPath = incomingSegments[0]\n  let locale = incomingLocale\n  const rootTableName = incomingRootTableName || tableName\n  let constraintPath = incomingConstraintPath || ''\n\n  const field = fields.find((fieldToFind) => fieldToFind.name === fieldPath)\n  let newTableName = tableName\n\n  if (!field && fieldPath === 'id') {\n    selectFields.id = adapter.tables[newTableName].id\n    return {\n      columnName: 'id',\n      constraints,\n      field: {\n        name: 'id',\n        type: adapter.idType === 'uuid' ? 'text' : 'number',\n      } as NumberField | TextField,\n      table: adapter.tables[newTableName],\n    }\n  }\n\n  if (field) {\n    const pathSegments = [...incomingSegments]\n\n    const isFieldLocalized = fieldShouldBeLocalized({ field, parentIsLocalized })\n\n    // If next segment is a locale,\n    // we need to take it out and use it as the locale from this point on\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      const matchedLocale = adapter.payload.config.localization.localeCodes.find(\n        (locale) => locale === pathSegments[1],\n      )\n\n      if (matchedLocale) {\n        locale = matchedLocale\n        pathSegments.splice(1, 1)\n      }\n    }\n\n    switch (field.type) {\n      case 'array': {\n        newTableName = adapter.tableNameMap.get(\n          `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n        )\n\n        const arrayParentTable = aliasTable || adapter.tables[tableName]\n\n        constraintPath = `${constraintPath}${field.name}.%.`\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          const conditions = [eq(arrayParentTable.id, adapter.tables[newTableName]._parentID)]\n\n          if (selectLocale) {\n            selectFields._locale = adapter.tables[newTableName]._locale\n          }\n\n          if (locale !== 'all') {\n            conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n          }\n          addJoinTable({\n            condition: and(...conditions),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        } else {\n          addJoinTable({\n            condition: eq(arrayParentTable.id, adapter.tables[newTableName]._parentID),\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          collectionPath,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          value,\n        })\n      }\n      case 'blocks': {\n        let blockTableColumn: TableColumn\n        let newTableName: string\n\n        // handle blockType queries\n        if (pathSegments[1] === 'blockType') {\n          // find the block config using the value\n          const blockTypes = Array.isArray(value) ? value : [value]\n          blockTypes.forEach((blockType) => {\n            const block =\n              adapter.payload.blocks[blockType] ??\n              ((field.blockReferences ?? field.blocks).find(\n                (block) => typeof block !== 'string' && block.slug === blockType,\n              ) as FlattenedBlock | undefined)\n\n            newTableName = adapter.tableNameMap.get(\n              `${tableName}_blocks_${toSnakeCase(block.slug)}`,\n            )\n\n            const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n            joins.push({\n              condition: eq(adapter.tables[tableName].id, newAliasTable._parentID),\n              table: newAliasTable,\n            })\n            constraints.push({\n              columnName: '_path',\n              table: newAliasTable,\n              value: pathSegments[0],\n            })\n          })\n          return {\n            constraints,\n            field,\n            getNotNullColumnByValue: () => 'id',\n            table: adapter.tables[tableName],\n          }\n        }\n\n        const hasBlockField = (field.blockReferences ?? field.blocks).some((_block) => {\n          const block = typeof _block === 'string' ? adapter.payload.blocks[_block] : _block\n\n          newTableName = adapter.tableNameMap.get(`${tableName}_blocks_${toSnakeCase(block.slug)}`)\n          constraintPath = `${constraintPath}${field.name}.%.`\n\n          let result: TableColumn\n          const blockConstraints = []\n          const blockSelectFields = {}\n\n          let blockJoin: BuildQueryJoinAliases[0]\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            blockJoin = {\n              condition: and(...conditions),\n              table: adapter.tables[newTableName],\n            }\n          } else {\n            blockJoin = {\n              condition: eq(\n                (aliasTable || adapter.tables[tableName]).id,\n                adapter.tables[newTableName]._parentID,\n              ),\n              table: adapter.tables[newTableName],\n            }\n          }\n\n          // Create a new reference for nested joins\n          const newJoins = [...joins]\n\n          try {\n            result = getTableColumnFromPath({\n              adapter,\n              collectionPath,\n              constraintPath,\n              constraints: blockConstraints,\n              fields: block.flattenedFields,\n              joins: newJoins,\n              locale,\n              parentIsLocalized: parentIsLocalized || field.localized,\n              pathSegments: pathSegments.slice(1),\n              rootTableName,\n              selectFields: blockSelectFields,\n              selectLocale,\n              tableName: newTableName,\n              value,\n            })\n          } catch (error) {\n            // this is fine, not every block will have the field\n          }\n          if (!result) {\n            return\n          }\n          blockTableColumn = result\n          constraints = constraints.concat(blockConstraints)\n          selectFields = { ...selectFields, ...blockSelectFields }\n\n          const previousLength = joins.length\n          joins.push(blockJoin)\n          // Append new joins AFTER the block join to prevent errors with missing FROM clause.\n          if (newJoins.length > previousLength) {\n            for (let i = previousLength; i < newJoins.length; i++) {\n              joins.push(newJoins[i])\n            }\n          }\n          return true\n        })\n        if (hasBlockField) {\n          return {\n            columnName: blockTableColumn.columnName,\n            constraints,\n            field: blockTableColumn.field,\n            pathSegments: pathSegments.slice(1),\n            rawColumn: blockTableColumn.rawColumn,\n            table: blockTableColumn.table,\n          }\n        }\n        break\n      }\n\n      case 'group': {\n        if (locale && isFieldLocalized && adapter.payload.config.localization) {\n          newTableName = `${tableName}${adapter.localesSuffix}`\n\n          let condition = eq(adapter.tables[tableName].id, adapter.tables[newTableName]._parentID)\n\n          if (locale !== 'all') {\n            condition = and(condition, eq(adapter.tables[newTableName]._locale, locale))\n          }\n\n          addJoinTable({\n            condition,\n            joins,\n            table: adapter.tables[newTableName],\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix: `${columnPrefix}${field.name}_`,\n          constraintPath: `${constraintPath}${field.name}.`,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n          value,\n        })\n      }\n\n      case 'join': {\n        if (Array.isArray(field.collection)) {\n          throw new APIError('Not supported')\n        }\n\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (field.hasMany) {\n          const relationTableName = `${adapter.tableNameMap.get(toSnakeCase(field.collection))}${adapter.relationshipsSuffix}`\n          const { newAliasTable: aliasRelationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          const relationshipField = getFieldByPath({\n            fields: adapter.payload.collections[field.collection].config.flattenedFields,\n            path: field.on,\n          })\n          if (!relationshipField) {\n            throw new APIError('Relationship was not found')\n          }\n\n          addJoinTable({\n            condition: and(\n              eq(\n                adapter.tables[rootTableName].id,\n                aliasRelationshipTable[\n                  `${(relationshipField.field as RelationshipField).relationTo as string}ID`\n                ],\n              ),\n              like(aliasRelationshipTable.path, field.on),\n            ),\n            joins,\n            queryPath: field.on,\n            table: aliasRelationshipTable,\n          })\n\n          const relationshipConfig = adapter.payload.collections[field.collection].config\n          const relationshipTableName = adapter.tableNameMap.get(\n            toSnakeCase(relationshipConfig.slug),\n          )\n\n          // parent to relationship join table\n          const relationshipFields = relationshipConfig.flattenedFields\n\n          const { newAliasTable: relationshipTable } = getTableAlias({\n            adapter,\n            tableName: relationshipTableName,\n          })\n\n          joins.push({\n            condition: eq(aliasRelationshipTable.parent, relationshipTable.id),\n            table: relationshipTable,\n          })\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: relationshipTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: relationshipTableName,\n            selectFields,\n            selectLocale,\n            tableName: relationshipTableName,\n            value,\n          })\n        }\n\n        const newTableName = adapter.tableNameMap.get(\n          toSnakeCase(adapter.payload.collections[field.collection].config.slug),\n        )\n        const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n        joins.push({\n          condition: eq(\n            newAliasTable[field.on.replaceAll('.', '_')],\n            aliasTable ? aliasTable.id : adapter.tables[tableName].id,\n          ),\n          table: newAliasTable,\n        })\n\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable: newAliasTable,\n          collectionPath: newCollectionPath,\n          constraintPath: '',\n          constraints,\n          fields: adapter.payload.collections[field.collection].config.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          selectFields,\n          tableName: newTableName,\n          value,\n        })\n\n        break\n      }\n\n      case 'number':\n      case 'text': {\n        if (field.hasMany) {\n          let tableType = 'texts'\n          let columnName = 'text'\n          if (field.type === 'number') {\n            tableType = 'numbers'\n            columnName = 'number'\n          }\n          newTableName = `${rootTableName}_${tableType}`\n          const joinConstraints = [\n            eq(adapter.tables[rootTableName].id, adapter.tables[newTableName].parent),\n            like(adapter.tables[newTableName].path, `${constraintPath}${field.name}`),\n          ]\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [...joinConstraints]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: and(...joinConstraints),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName,\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n      case 'relationship':\n      case 'upload': {\n        const newCollectionPath = pathSegments.slice(1).join('.')\n\n        if (Array.isArray(field.relationTo) || field.hasMany) {\n          let relationshipFields: FlattenedField[]\n          const relationTableName = `${rootTableName}${adapter.relationshipsSuffix}`\n          const {\n            newAliasTable: aliasRelationshipTable,\n            newAliasTableName: aliasRelationshipTableName,\n          } = getTableAlias({\n            adapter,\n            tableName: relationTableName,\n          })\n\n          if (selectLocale && isFieldLocalized && adapter.payload.config.localization) {\n            selectFields._locale = aliasRelationshipTable.locale\n          }\n\n          // Join in the relationships table\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n              like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(aliasRelationshipTable.locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          } else {\n            // Join in the relationships table\n            addJoinTable({\n              condition: and(\n                eq((aliasTable || adapter.tables[rootTableName]).id, aliasRelationshipTable.parent),\n                like(aliasRelationshipTable.path, `${constraintPath}${field.name}`),\n              ),\n              joins,\n              queryPath: `${constraintPath}.${field.name}`,\n              table: aliasRelationshipTable,\n            })\n          }\n\n          selectFields[`${relationTableName}.path`] = aliasRelationshipTable.path\n\n          let newAliasTable\n\n          if (typeof field.relationTo === 'string') {\n            const relationshipConfig = adapter.payload.collections[field.relationTo].config\n\n            newTableName = adapter.tableNameMap.get(toSnakeCase(relationshipConfig.slug))\n\n            // parent to relationship join table\n            relationshipFields = relationshipConfig.flattenedFields\n            ;({ newAliasTable } = getTableAlias({ adapter, tableName: newTableName }))\n\n            joins.push({\n              condition: eq(newAliasTable.id, aliasRelationshipTable[`${field.relationTo}ID`]),\n              table: newAliasTable,\n            })\n\n            if (newCollectionPath === '' || newCollectionPath === 'id') {\n              return {\n                columnName: `${field.relationTo}ID`,\n                constraints,\n                field,\n                table: aliasRelationshipTable,\n              }\n            }\n          } else if (newCollectionPath === 'value') {\n            const hasCustomCollectionWithCustomID = field.relationTo.some(\n              (relationTo) => !!adapter.payload.collections[relationTo].customIDType,\n            )\n\n            const columns: TableColumn['columns'] = field.relationTo\n              .map((relationTo) => {\n                let idType: 'number' | 'text' | 'uuid' =\n                  adapter.idType === 'uuid' ? 'uuid' : 'number'\n\n                const { customIDType } = adapter.payload.collections[relationTo]\n\n                if (customIDType) {\n                  idType = customIDType\n                }\n\n                const idTypeTextOrUuid = idType === 'text' || idType === 'uuid'\n\n                // Do not add the column to OR if we know that it can't match by the type\n                // We can't do the same with idType: 'number' because `value` can be from the REST search query params\n                if (typeof value === 'number' && idTypeTextOrUuid) {\n                  return null\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  value.every((val) => typeof val === 'number') &&\n                  idTypeTextOrUuid\n                ) {\n                  return null\n                }\n\n                // Do not add the UUID type column if incoming query value doesn't match UUID. If there aren't any collections with\n                // a custom ID type, we skip this check\n                // We need this because Postgres throws an error if querying by UUID column with a value that isn't a valid UUID.\n                if (\n                  value &&\n                  !Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID\n                ) {\n                  if (!uuidValidate(value)) {\n                    return null\n                  }\n                }\n\n                if (\n                  Array.isArray(value) &&\n                  idType === 'uuid' &&\n                  hasCustomCollectionWithCustomID &&\n                  !value.some((val) => uuidValidate(val))\n                ) {\n                  return null\n                }\n\n                const relationTableName = adapter.tableNameMap.get(\n                  toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n                )\n\n                return {\n                  idType,\n                  rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n                }\n              })\n              .filter(Boolean)\n\n            return {\n              columns,\n              constraints,\n              field,\n              table: aliasRelationshipTable,\n            }\n          } else if (newCollectionPath === 'relationTo') {\n            const relationTo = Array.isArray(field.relationTo)\n              ? field.relationTo\n              : [field.relationTo]\n\n            return {\n              constraints,\n              field,\n              getNotNullColumnByValue: (val) => {\n                const matchedRelation = relationTo.find((relation) => relation === val)\n                if (matchedRelation) {\n                  return `${matchedRelation}ID`\n                }\n                return undefined\n              },\n              table: aliasRelationshipTable,\n            }\n          } else if (isPolymorphicRelationship(value)) {\n            const { relationTo } = value\n\n            const relationTableName = adapter.tableNameMap.get(\n              toSnakeCase(adapter.payload.collections[relationTo].config.slug),\n            )\n\n            return {\n              constraints,\n              field,\n              rawColumn: sql.raw(`\"${aliasRelationshipTableName}\".\"${relationTableName}_id\"`),\n              table: aliasRelationshipTable,\n            }\n          } else {\n            throw new APIError('Not supported')\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraints,\n            // relationshipFields are fields from a different collection => no parentIsLocalized\n            fields: relationshipFields,\n            joins,\n            locale,\n            parentIsLocalized: false,\n            pathSegments: pathSegments.slice(1),\n            rootTableName: newTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            value,\n          })\n        } else if (\n          pathSegments.length > 1 &&\n          !(pathSegments.length === 2 && pathSegments[1] === 'id')\n        ) {\n          // simple relationships\n          const columnName = `${columnPrefix}${field.name}`\n          const newTableName = adapter.tableNameMap.get(\n            toSnakeCase(adapter.payload.collections[field.relationTo].config.slug),\n          )\n          const { newAliasTable } = getTableAlias({ adapter, tableName: newTableName })\n\n          if (isFieldLocalized && adapter.payload.config.localization) {\n            const { newAliasTable: aliasLocaleTable } = getTableAlias({\n              adapter,\n              tableName: `${rootTableName}${adapter.localesSuffix}`,\n            })\n\n            const condtions = [eq(aliasLocaleTable._parentID, adapter.tables[rootTableName].id)]\n\n            if (selectLocale) {\n              selectFields._locale = aliasLocaleTable._locale\n            }\n\n            if (locale !== 'all') {\n              condtions.push(eq(aliasLocaleTable._locale, locale))\n            }\n\n            const localesTable = adapter.tables[`${rootTableName}${adapter.localesSuffix}`]\n\n            addJoinTable({\n              condition: and(...condtions),\n              joins,\n              table: localesTable,\n            })\n\n            joins.push({\n              condition: eq(localesTable[columnName], newAliasTable.id),\n              table: newAliasTable,\n            })\n          } else {\n            joins.push({\n              condition: eq(\n                newAliasTable.id,\n                aliasTable ? aliasTable[columnName] : adapter.tables[tableName][columnName],\n              ),\n              table: newAliasTable,\n            })\n          }\n\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable: newAliasTable,\n            collectionPath: newCollectionPath,\n            constraintPath: '',\n            constraints,\n            fields: adapter.payload.collections[field.relationTo].config.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            selectFields,\n            tableName: newTableName,\n            value,\n          })\n        }\n\n        break\n      }\n\n      case 'select': {\n        if (field.hasMany) {\n          const newTableName = adapter.tableNameMap.get(\n            `${tableName}_${tableNameSuffix}${toSnakeCase(field.name)}`,\n          )\n\n          if (locale && isFieldLocalized && adapter.payload.config.localization) {\n            const conditions = [\n              eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              eq(adapter.tables[newTableName]._locale, locale),\n            ]\n\n            if (locale !== 'all') {\n              conditions.push(eq(adapter.tables[newTableName]._locale, locale))\n            }\n\n            addJoinTable({\n              condition: and(...conditions),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          } else {\n            addJoinTable({\n              condition: eq(adapter.tables[tableName].id, adapter.tables[newTableName].parent),\n              joins,\n              table: adapter.tables[newTableName],\n            })\n          }\n\n          return {\n            columnName: 'value',\n            constraints,\n            field,\n            table: adapter.tables[newTableName],\n          }\n        }\n        break\n      }\n\n      case 'tab': {\n        if (tabHasName(field)) {\n          return getTableColumnFromPath({\n            adapter,\n            aliasTable,\n            collectionPath,\n            columnPrefix: `${columnPrefix}${field.name}_`,\n            constraintPath: `${constraintPath}${field.name}.`,\n            constraints,\n            fields: field.flattenedFields,\n            joins,\n            locale,\n            parentIsLocalized: parentIsLocalized || field.localized,\n            pathSegments: pathSegments.slice(1),\n            rootTableName,\n            selectFields,\n            selectLocale,\n            tableName: newTableName,\n            tableNameSuffix: `${tableNameSuffix}${toSnakeCase(field.name)}_`,\n            value,\n          })\n        }\n        return getTableColumnFromPath({\n          adapter,\n          aliasTable,\n          collectionPath,\n          columnPrefix,\n          constraintPath,\n          constraints,\n          fields: field.flattenedFields,\n          joins,\n          locale,\n          parentIsLocalized: parentIsLocalized || field.localized,\n          pathSegments: pathSegments.slice(1),\n          rootTableName,\n          selectFields,\n          selectLocale,\n          tableName: newTableName,\n          tableNameSuffix,\n          value,\n        })\n      }\n\n      default: {\n        // fall through\n        break\n      }\n    }\n\n    let newTable = adapter.tables[newTableName]\n\n    if (isFieldLocalized && adapter.payload.config.localization) {\n      // If localized, we go to localized table and set aliasTable to undefined\n      // so it is not picked up below to be used as targetTable\n      const parentTable = aliasTable || adapter.tables[tableName]\n      newTableName = `${tableName}${adapter.localesSuffix}`\n\n      newTable = adapter.tables[newTableName]\n\n      let condition = eq(parentTable.id, newTable._parentID)\n\n      if (locale !== 'all') {\n        condition = and(condition, eq(newTable._locale, locale))\n      }\n\n      if (selectLocale) {\n        selectFields._locale = newTable._locale\n      }\n\n      addJoinTable({\n        condition,\n        joins,\n        table: newTable,\n      })\n\n      aliasTable = undefined\n    }\n\n    const targetTable = aliasTable || newTable\n\n    selectFields[`${newTableName}.${columnPrefix}${field.name}`] =\n      targetTable[`${columnPrefix}${field.name}`]\n\n    return {\n      columnName: `${columnPrefix}${field.name}`,\n      constraints,\n      field,\n      pathSegments,\n      table: targetTable,\n    }\n  }\n\n  throw new APIError(`Cannot find field for path at ${fieldPath}`)\n}\n"],"names":["and","eq","like","sql","APIError","getFieldByPath","fieldShouldBeLocalized","tabHasName","toSnakeCase","validate","uuidValidate","isPolymorphicRelationship","addJoinTable","getTableAlias","getTableColumnFromPath","adapter","aliasTable","collectionPath","columnPrefix","constraintPath","incomingConstraintPath","constraints","fields","joins","locale","incomingLocale","parentIsLocalized","pathSegments","incomingSegments","rootTableName","incomingRootTableName","selectFields","selectLocale","tableName","tableNameSuffix","value","fieldPath","field","find","fieldToFind","name","newTableName","id","tables","columnName","type","idType","table","isFieldLocalized","payload","config","localization","matchedLocale","localeCodes","splice","tableNameMap","get","arrayParentTable","conditions","_parentID","_locale","push","condition","flattenedFields","localized","slice","blockTableColumn","blockTypes","Array","isArray","forEach","blockType","block","blocks","blockReferences","slug","newAliasTable","getNotNullColumnByValue","hasBlockField","some","_block","result","blockConstraints","blockSelectFields","blockJoin","newJoins","error","concat","previousLength","length","i","rawColumn","localesSuffix","collection","newCollectionPath","join","hasMany","relationTableName","relationshipsSuffix","aliasRelationshipTable","relationshipField","collections","path","on","relationTo","queryPath","relationshipConfig","relationshipTableName","relationshipFields","relationshipTable","parent","replaceAll","tableType","joinConstraints","newAliasTableName","aliasRelationshipTableName","hasCustomCollectionWithCustomID","customIDType","columns","map","idTypeTextOrUuid","every","val","raw","filter","Boolean","matchedRelation","relation","undefined","aliasLocaleTable","condtions","localesTable","newTable","parentTable","targetTable"],"mappings":"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"}