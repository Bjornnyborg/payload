{"version":3,"sources":["../../src/upsertRow/index.ts"],"sourcesContent":["import type { TypeWithID } from 'payload'\n\nimport { eq } from 'drizzle-orm'\nimport { ValidationError } from 'payload'\n\nimport type { BlockRowToInsert } from '../transform/write/types.js'\nimport type { Args } from './types.js'\n\nimport { buildFindManyArgs } from '../find/buildFindManyArgs.js'\nimport { transform } from '../transform/read/index.js'\nimport { transformForWrite } from '../transform/write/index.js'\nimport { deleteExistingArrayRows } from './deleteExistingArrayRows.js'\nimport { deleteExistingRowsByPath } from './deleteExistingRowsByPath.js'\nimport { insertArrays } from './insertArrays.js'\n\nexport const upsertRow = async <T extends Record<string, unknown> | TypeWithID>({\n  id,\n  adapter,\n  data,\n  db,\n  fields,\n  ignoreResult,\n  // TODO:\n  // When we support joins for write operations (create/update) - pass collectionSlug to the buildFindManyArgs\n  // Make a new argument in upsertRow.ts and pass the slug from every operation.\n  joinQuery: _joinQuery,\n  operation,\n  path = '',\n  req,\n  select,\n  tableName,\n  upsertTarget,\n  where,\n}: Args): Promise<T> => {\n  // Split out the incoming data into the corresponding:\n  // base row, locales, relationships, blocks, and arrays\n  const rowToInsert = transformForWrite({\n    adapter,\n    data,\n    fields,\n    path,\n    tableName,\n  })\n\n  // First, we insert the main row\n  let insertedRow: Record<string, unknown>\n\n  try {\n    if (operation === 'update') {\n      const target = upsertTarget || adapter.tables[tableName].id\n\n      if (id) {\n        rowToInsert.row.id = id\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target },\n          tableName,\n          values: rowToInsert.row,\n        })\n      } else {\n        ;[insertedRow] = await adapter.insert({\n          db,\n          onConflictDoUpdate: { set: rowToInsert.row, target, where },\n          tableName,\n          values: rowToInsert.row,\n        })\n      }\n    } else {\n      if (adapter.allowIDOnCreate && data.id) {\n        rowToInsert.row.id = data.id\n      }\n      ;[insertedRow] = await adapter.insert({\n        db,\n        tableName,\n        values: rowToInsert.row,\n      })\n    }\n\n    const localesToInsert: Record<string, unknown>[] = []\n    const relationsToInsert: Record<string, unknown>[] = []\n    const textsToInsert: Record<string, unknown>[] = []\n    const numbersToInsert: Record<string, unknown>[] = []\n    const blocksToInsert: { [blockType: string]: BlockRowToInsert[] } = {}\n    const selectsToInsert: { [selectTableName: string]: Record<string, unknown>[] } = {}\n\n    // If there are locale rows with data, add the parent and locale to each\n    if (Object.keys(rowToInsert.locales).length > 0) {\n      Object.entries(rowToInsert.locales).forEach(([locale, localeRow]) => {\n        localeRow._parentID = insertedRow.id\n        localeRow._locale = locale\n        localesToInsert.push(localeRow)\n      })\n    }\n\n    // If there are relationships, add parent to each\n    if (rowToInsert.relationships.length > 0) {\n      rowToInsert.relationships.forEach((relation) => {\n        relation.parent = insertedRow.id\n        relationsToInsert.push(relation)\n      })\n    }\n\n    // If there are texts, add parent to each\n    if (rowToInsert.texts.length > 0) {\n      rowToInsert.texts.forEach((textRow) => {\n        textRow.parent = insertedRow.id\n        textsToInsert.push(textRow)\n      })\n    }\n\n    // If there are numbers, add parent to each\n    if (rowToInsert.numbers.length > 0) {\n      rowToInsert.numbers.forEach((numberRow) => {\n        numberRow.parent = insertedRow.id\n        numbersToInsert.push(numberRow)\n      })\n    }\n\n    // If there are selects, add parent to each, and then\n    // store by table name and rows\n    if (Object.keys(rowToInsert.selects).length > 0) {\n      Object.entries(rowToInsert.selects).forEach(([selectTableName, selectRows]) => {\n        selectsToInsert[selectTableName] = []\n\n        selectRows.forEach((row) => {\n          if (typeof row.parent === 'undefined') {\n            row.parent = insertedRow.id\n          }\n\n          selectsToInsert[selectTableName].push(row)\n        })\n      })\n    }\n\n    // If there are blocks, add parent to each, and then\n    // store by table name and rows\n    Object.keys(rowToInsert.blocks).forEach((blockName) => {\n      rowToInsert.blocks[blockName].forEach((blockRow) => {\n        blockRow.row._parentID = insertedRow.id\n        if (!blocksToInsert[blockName]) {\n          blocksToInsert[blockName] = []\n        }\n        if (blockRow.row.uuid) {\n          delete blockRow.row.uuid\n        }\n        blocksToInsert[blockName].push(blockRow)\n      })\n    })\n\n    // //////////////////////////////////\n    // INSERT LOCALES\n    // //////////////////////////////////\n\n    if (localesToInsert.length > 0) {\n      const localeTableName = `${tableName}${adapter.localesSuffix}`\n      const localeTable = adapter.tables[`${tableName}${adapter.localesSuffix}`]\n\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: localeTableName,\n          where: eq(localeTable._parentID, insertedRow.id),\n        })\n      }\n\n      await adapter.insert({\n        db,\n        tableName: localeTableName,\n        values: localesToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT RELATIONSHIPS\n    // //////////////////////////////////\n\n    const relationshipsTableName = `${tableName}${adapter.relationshipsSuffix}`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: [...relationsToInsert, ...rowToInsert.relationshipsToDelete],\n        tableName: relationshipsTableName,\n      })\n    }\n\n    if (relationsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: relationshipsTableName,\n        values: relationsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany TEXTS\n    // //////////////////////////////////\n\n    const textsTableName = `${tableName}_texts`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: textsToInsert,\n        tableName: textsTableName,\n      })\n    }\n\n    if (textsToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: textsTableName,\n        values: textsToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT hasMany NUMBERS\n    // //////////////////////////////////\n\n    const numbersTableName = `${tableName}_numbers`\n\n    if (operation === 'update') {\n      await deleteExistingRowsByPath({\n        adapter,\n        db,\n        localeColumnName: 'locale',\n        parentColumnName: 'parent',\n        parentID: insertedRow.id,\n        pathColumnName: 'path',\n        rows: numbersToInsert,\n        tableName: numbersTableName,\n      })\n    }\n\n    if (numbersToInsert.length > 0) {\n      await adapter.insert({\n        db,\n        tableName: numbersTableName,\n        values: numbersToInsert,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT BLOCKS\n    // //////////////////////////////////\n\n    const insertedBlockRows: Record<string, Record<string, unknown>[]> = {}\n\n    if (operation === 'update') {\n      for (const blockName of rowToInsert.blocksToDelete) {\n        const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n        const blockTable = adapter.tables[blockTableName]\n        await adapter.deleteWhere({\n          db,\n          tableName: blockTableName,\n          where: eq(blockTable._parentID, insertedRow.id),\n        })\n      }\n    }\n\n    // When versions are enabled, this is used to track mapping between blocks/arrays ObjectID to their numeric generated representation, then we use it for nested to arrays/blocks select hasMany in versions.\n    const arraysBlocksUUIDMap: Record<string, number | string> = {}\n\n    for (const [blockName, blockRows] of Object.entries(blocksToInsert)) {\n      const blockTableName = adapter.tableNameMap.get(`${tableName}_blocks_${blockName}`)\n      insertedBlockRows[blockName] = await adapter.insert({\n        db,\n        tableName: blockTableName,\n        values: blockRows.map(({ row }) => row),\n      })\n\n      insertedBlockRows[blockName].forEach((row, i) => {\n        blockRows[i].row = row\n        if (\n          typeof row._uuid === 'string' &&\n          (typeof row.id === 'string' || typeof row.id === 'number')\n        ) {\n          arraysBlocksUUIDMap[row._uuid] = row.id\n        }\n      })\n\n      const blockLocaleIndexMap: number[] = []\n\n      const blockLocaleRowsToInsert = blockRows.reduce((acc, blockRow, i) => {\n        if (Object.entries(blockRow.locales).length > 0) {\n          Object.entries(blockRow.locales).forEach(([blockLocale, blockLocaleData]) => {\n            if (Object.keys(blockLocaleData).length > 0) {\n              blockLocaleData._parentID = blockRow.row.id\n              blockLocaleData._locale = blockLocale\n              acc.push(blockLocaleData)\n              blockLocaleIndexMap.push(i)\n            }\n          })\n        }\n\n        return acc\n      }, [])\n\n      if (blockLocaleRowsToInsert.length > 0) {\n        await adapter.insert({\n          db,\n          tableName: `${blockTableName}${adapter.localesSuffix}`,\n          values: blockLocaleRowsToInsert,\n        })\n      }\n\n      await insertArrays({\n        adapter,\n        arrays: blockRows.map(({ arrays }) => arrays),\n        db,\n        parentRows: insertedBlockRows[blockName],\n        uuidMap: arraysBlocksUUIDMap,\n      })\n    }\n\n    // //////////////////////////////////\n    // INSERT ARRAYS RECURSIVELY\n    // //////////////////////////////////\n\n    if (operation === 'update') {\n      for (const arrayTableName of Object.keys(rowToInsert.arrays)) {\n        await deleteExistingArrayRows({\n          adapter,\n          db,\n          parentID: insertedRow.id,\n          tableName: arrayTableName,\n        })\n      }\n    }\n\n    await insertArrays({\n      adapter,\n      arrays: [rowToInsert.arrays],\n      db,\n      parentRows: [insertedRow],\n      uuidMap: arraysBlocksUUIDMap,\n    })\n\n    // //////////////////////////////////\n    // INSERT hasMany SELECTS\n    // //////////////////////////////////\n\n    for (const [selectTableName, tableRows] of Object.entries(selectsToInsert)) {\n      const selectTable = adapter.tables[selectTableName]\n      if (operation === 'update') {\n        await adapter.deleteWhere({\n          db,\n          tableName: selectTableName,\n          where: eq(selectTable.parent, insertedRow.id),\n        })\n      }\n\n      if (Object.keys(arraysBlocksUUIDMap).length > 0) {\n        tableRows.forEach((row: any) => {\n          if (row.parent in arraysBlocksUUIDMap) {\n            row.parent = arraysBlocksUUIDMap[row.parent]\n          }\n        })\n      }\n\n      if (tableRows.length) {\n        await adapter.insert({\n          db,\n          tableName: selectTableName,\n          values: tableRows,\n        })\n      }\n    }\n\n    // //////////////////////////////////\n    // Error Handling\n    // //////////////////////////////////\n  } catch (error) {\n    if (error.code === '23505') {\n      let fieldName: null | string = null\n      // We need to try and find the right constraint for the field but if we can't we fallback to a generic message\n      if (adapter.fieldConstraints?.[tableName]) {\n        if (adapter.fieldConstraints[tableName]?.[error.constraint]) {\n          fieldName = adapter.fieldConstraints[tableName]?.[error.constraint]\n        } else {\n          const replacement = `${tableName}_`\n\n          if (error.constraint.includes(replacement)) {\n            const replacedConstraint = error.constraint.replace(replacement, '')\n\n            if (replacedConstraint && adapter.fieldConstraints[tableName]?.[replacedConstraint]) {\n              fieldName = adapter.fieldConstraints[tableName][replacedConstraint]\n            }\n          }\n        }\n      }\n\n      if (!fieldName) {\n        // Last case scenario we extract the key and value from the detail on the error\n        const detail = error.detail\n        const regex = /Key \\(([^)]+)\\)=\\(([^)]+)\\)/\n        const match = detail.match(regex)\n\n        if (match) {\n          const key = match[1]\n\n          fieldName = key\n        }\n      }\n\n      throw new ValidationError(\n        {\n          id,\n          errors: [\n            {\n              message: req?.t ? req.t('error:valueMustBeUnique') : 'Value must be unique',\n              path: fieldName,\n            },\n          ],\n          req,\n        },\n        req?.t,\n      )\n    } else {\n      throw error\n    }\n  }\n\n  if (ignoreResult === 'idOnly') {\n    return { id: insertedRow.id } as T\n  }\n\n  if (ignoreResult) {\n    return data as T\n  }\n\n  // //////////////////////////////////\n  // RETRIEVE NEWLY UPDATED ROW\n  // //////////////////////////////////\n\n  const findManyArgs = buildFindManyArgs({\n    adapter,\n    depth: 0,\n    fields,\n    joinQuery: false,\n    select,\n    tableName,\n  })\n\n  findManyArgs.where = eq(adapter.tables[tableName].id, insertedRow.id)\n\n  const doc = await db.query[tableName].findFirst(findManyArgs)\n\n  // //////////////////////////////////\n  // TRANSFORM DATA\n  // //////////////////////////////////\n\n  const result = transform<T>({\n    adapter,\n    config: adapter.payload.config,\n    data: doc,\n    fields,\n    joinQuery: false,\n    tableName,\n  })\n\n  return result\n}\n"],"names":["eq","ValidationError","buildFindManyArgs","transform","transformForWrite","deleteExistingArrayRows","deleteExistingRowsByPath","insertArrays","upsertRow","id","adapter","data","db","fields","ignoreResult","joinQuery","_joinQuery","operation","path","req","select","tableName","upsertTarget","where","rowToInsert","insertedRow","target","tables","row","insert","onConflictDoUpdate","set","values","allowIDOnCreate","localesToInsert","relationsToInsert","textsToInsert","numbersToInsert","blocksToInsert","selectsToInsert","Object","keys","locales","length","entries","forEach","locale","localeRow","_parentID","_locale","push","relationships","relation","parent","texts","textRow","numbers","numberRow","selects","selectTableName","selectRows","blocks","blockName","blockRow","uuid","localeTableName","localesSuffix","localeTable","deleteWhere","relationshipsTableName","relationshipsSuffix","localeColumnName","parentColumnName","parentID","pathColumnName","rows","relationshipsToDelete","textsTableName","numbersTableName","insertedBlockRows","blocksToDelete","blockTableName","tableNameMap","get","blockTable","arraysBlocksUUIDMap","blockRows","map","i","_uuid","blockLocaleIndexMap","blockLocaleRowsToInsert","reduce","acc","blockLocale","blockLocaleData","arrays","parentRows","uuidMap","arrayTableName","tableRows","selectTable","error","code","fieldName","fieldConstraints","constraint","replacement","includes","replacedConstraint","replace","detail","regex","match","key","errors","message","t","findManyArgs","depth","doc","query","findFirst","result","config","payload"],"mappings":"AAEA,SAASA,EAAE,QAAQ,cAAa;AAChC,SAASC,eAAe,QAAQ,UAAS;AAKzC,SAASC,iBAAiB,QAAQ,+BAA8B;AAChE,SAASC,SAAS,QAAQ,6BAA4B;AACtD,SAASC,iBAAiB,QAAQ,8BAA6B;AAC/D,SAASC,uBAAuB,QAAQ,+BAA8B;AACtE,SAASC,wBAAwB,QAAQ,gCAA+B;AACxE,SAASC,YAAY,QAAQ,oBAAmB;AAEhD,OAAO,MAAMC,YAAY,OAAuD,EAC9EC,EAAE,EACFC,OAAO,EACPC,IAAI,EACJC,EAAE,EACFC,MAAM,EACNC,YAAY,EACZ,QAAQ;AACR,4GAA4G;AAC5G,8EAA8E;AAC9EC,WAAWC,UAAU,EACrBC,SAAS,EACTC,OAAO,EAAE,EACTC,GAAG,EACHC,MAAM,EACNC,SAAS,EACTC,YAAY,EACZC,KAAK,EACA;IACL,sDAAsD;IACtD,uDAAuD;IACvD,MAAMC,cAAcpB,kBAAkB;QACpCM;QACAC;QACAE;QACAK;QACAG;IACF;IAEA,gCAAgC;IAChC,IAAII;IAEJ,IAAI;QACF,IAAIR,cAAc,UAAU;YAC1B,MAAMS,SAASJ,gBAAgBZ,QAAQiB,MAAM,CAACN,UAAU,CAACZ,EAAE;YAE3D,IAAIA,IAAI;gBACNe,YAAYI,GAAG,CAACnB,EAAE,GAAGA;gBACpB,CAACgB,YAAY,GAAG,MAAMf,QAAQmB,MAAM,CAAC;oBACpCjB;oBACAkB,oBAAoB;wBAAEC,KAAKP,YAAYI,GAAG;wBAAEF;oBAAO;oBACnDL;oBACAW,QAAQR,YAAYI,GAAG;gBACzB;YACF,OAAO;;gBACJ,CAACH,YAAY,GAAG,MAAMf,QAAQmB,MAAM,CAAC;oBACpCjB;oBACAkB,oBAAoB;wBAAEC,KAAKP,YAAYI,GAAG;wBAAEF;wBAAQH;oBAAM;oBAC1DF;oBACAW,QAAQR,YAAYI,GAAG;gBACzB;YACF;QACF,OAAO;YACL,IAAIlB,QAAQuB,eAAe,IAAItB,KAAKF,EAAE,EAAE;gBACtCe,YAAYI,GAAG,CAACnB,EAAE,GAAGE,KAAKF,EAAE;YAC9B;;YACC,CAACgB,YAAY,GAAG,MAAMf,QAAQmB,MAAM,CAAC;gBACpCjB;gBACAS;gBACAW,QAAQR,YAAYI,GAAG;YACzB;QACF;QAEA,MAAMM,kBAA6C,EAAE;QACrD,MAAMC,oBAA+C,EAAE;QACvD,MAAMC,gBAA2C,EAAE;QACnD,MAAMC,kBAA6C,EAAE;QACrD,MAAMC,iBAA8D,CAAC;QACrE,MAAMC,kBAA4E,CAAC;QAEnF,wEAAwE;QACxE,IAAIC,OAAOC,IAAI,CAACjB,YAAYkB,OAAO,EAAEC,MAAM,GAAG,GAAG;YAC/CH,OAAOI,OAAO,CAACpB,YAAYkB,OAAO,EAAEG,OAAO,CAAC,CAAC,CAACC,QAAQC,UAAU;gBAC9DA,UAAUC,SAAS,GAAGvB,YAAYhB,EAAE;gBACpCsC,UAAUE,OAAO,GAAGH;gBACpBZ,gBAAgBgB,IAAI,CAACH;YACvB;QACF;QAEA,iDAAiD;QACjD,IAAIvB,YAAY2B,aAAa,CAACR,MAAM,GAAG,GAAG;YACxCnB,YAAY2B,aAAa,CAACN,OAAO,CAAC,CAACO;gBACjCA,SAASC,MAAM,GAAG5B,YAAYhB,EAAE;gBAChC0B,kBAAkBe,IAAI,CAACE;YACzB;QACF;QAEA,yCAAyC;QACzC,IAAI5B,YAAY8B,KAAK,CAACX,MAAM,GAAG,GAAG;YAChCnB,YAAY8B,KAAK,CAACT,OAAO,CAAC,CAACU;gBACzBA,QAAQF,MAAM,GAAG5B,YAAYhB,EAAE;gBAC/B2B,cAAcc,IAAI,CAACK;YACrB;QACF;QAEA,2CAA2C;QAC3C,IAAI/B,YAAYgC,OAAO,CAACb,MAAM,GAAG,GAAG;YAClCnB,YAAYgC,OAAO,CAACX,OAAO,CAAC,CAACY;gBAC3BA,UAAUJ,MAAM,GAAG5B,YAAYhB,EAAE;gBACjC4B,gBAAgBa,IAAI,CAACO;YACvB;QACF;QAEA,qDAAqD;QACrD,+BAA+B;QAC/B,IAAIjB,OAAOC,IAAI,CAACjB,YAAYkC,OAAO,EAAEf,MAAM,GAAG,GAAG;YAC/CH,OAAOI,OAAO,CAACpB,YAAYkC,OAAO,EAAEb,OAAO,CAAC,CAAC,CAACc,iBAAiBC,WAAW;gBACxErB,eAAe,CAACoB,gBAAgB,GAAG,EAAE;gBAErCC,WAAWf,OAAO,CAAC,CAACjB;oBAClB,IAAI,OAAOA,IAAIyB,MAAM,KAAK,aAAa;wBACrCzB,IAAIyB,MAAM,GAAG5B,YAAYhB,EAAE;oBAC7B;oBAEA8B,eAAe,CAACoB,gBAAgB,CAACT,IAAI,CAACtB;gBACxC;YACF;QACF;QAEA,oDAAoD;QACpD,+BAA+B;QAC/BY,OAAOC,IAAI,CAACjB,YAAYqC,MAAM,EAAEhB,OAAO,CAAC,CAACiB;YACvCtC,YAAYqC,MAAM,CAACC,UAAU,CAACjB,OAAO,CAAC,CAACkB;gBACrCA,SAASnC,GAAG,CAACoB,SAAS,GAAGvB,YAAYhB,EAAE;gBACvC,IAAI,CAAC6B,cAAc,CAACwB,UAAU,EAAE;oBAC9BxB,cAAc,CAACwB,UAAU,GAAG,EAAE;gBAChC;gBACA,IAAIC,SAASnC,GAAG,CAACoC,IAAI,EAAE;oBACrB,OAAOD,SAASnC,GAAG,CAACoC,IAAI;gBAC1B;gBACA1B,cAAc,CAACwB,UAAU,CAACZ,IAAI,CAACa;YACjC;QACF;QAEA,qCAAqC;QACrC,iBAAiB;QACjB,qCAAqC;QAErC,IAAI7B,gBAAgBS,MAAM,GAAG,GAAG;YAC9B,MAAMsB,kBAAkB,GAAG5C,YAAYX,QAAQwD,aAAa,EAAE;YAC9D,MAAMC,cAAczD,QAAQiB,MAAM,CAAC,GAAGN,YAAYX,QAAQwD,aAAa,EAAE,CAAC;YAE1E,IAAIjD,cAAc,UAAU;gBAC1B,MAAMP,QAAQ0D,WAAW,CAAC;oBACxBxD;oBACAS,WAAW4C;oBACX1C,OAAOvB,GAAGmE,YAAYnB,SAAS,EAAEvB,YAAYhB,EAAE;gBACjD;YACF;YAEA,MAAMC,QAAQmB,MAAM,CAAC;gBACnBjB;gBACAS,WAAW4C;gBACXjC,QAAQE;YACV;QACF;QAEA,qCAAqC;QACrC,uBAAuB;QACvB,qCAAqC;QAErC,MAAMmC,yBAAyB,GAAGhD,YAAYX,QAAQ4D,mBAAmB,EAAE;QAE3E,IAAIrD,cAAc,UAAU;YAC1B,MAAMX,yBAAyB;gBAC7BI;gBACAE;gBACA2D,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUhD,YAAYhB,EAAE;gBACxBiE,gBAAgB;gBAChBC,MAAM;uBAAIxC;uBAAsBX,YAAYoD,qBAAqB;iBAAC;gBAClEvD,WAAWgD;YACb;QACF;QAEA,IAAIlC,kBAAkBQ,MAAM,GAAG,GAAG;YAChC,MAAMjC,QAAQmB,MAAM,CAAC;gBACnBjB;gBACAS,WAAWgD;gBACXrC,QAAQG;YACV;QACF;QAEA,qCAAqC;QACrC,uBAAuB;QACvB,qCAAqC;QAErC,MAAM0C,iBAAiB,GAAGxD,UAAU,MAAM,CAAC;QAE3C,IAAIJ,cAAc,UAAU;YAC1B,MAAMX,yBAAyB;gBAC7BI;gBACAE;gBACA2D,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUhD,YAAYhB,EAAE;gBACxBiE,gBAAgB;gBAChBC,MAAMvC;gBACNf,WAAWwD;YACb;QACF;QAEA,IAAIzC,cAAcO,MAAM,GAAG,GAAG;YAC5B,MAAMjC,QAAQmB,MAAM,CAAC;gBACnBjB;gBACAS,WAAWwD;gBACX7C,QAAQI;YACV;QACF;QAEA,qCAAqC;QACrC,yBAAyB;QACzB,qCAAqC;QAErC,MAAM0C,mBAAmB,GAAGzD,UAAU,QAAQ,CAAC;QAE/C,IAAIJ,cAAc,UAAU;YAC1B,MAAMX,yBAAyB;gBAC7BI;gBACAE;gBACA2D,kBAAkB;gBAClBC,kBAAkB;gBAClBC,UAAUhD,YAAYhB,EAAE;gBACxBiE,gBAAgB;gBAChBC,MAAMtC;gBACNhB,WAAWyD;YACb;QACF;QAEA,IAAIzC,gBAAgBM,MAAM,GAAG,GAAG;YAC9B,MAAMjC,QAAQmB,MAAM,CAAC;gBACnBjB;gBACAS,WAAWyD;gBACX9C,QAAQK;YACV;QACF;QAEA,qCAAqC;QACrC,gBAAgB;QAChB,qCAAqC;QAErC,MAAM0C,oBAA+D,CAAC;QAEtE,IAAI9D,cAAc,UAAU;YAC1B,KAAK,MAAM6C,aAAatC,YAAYwD,cAAc,CAAE;gBAClD,MAAMC,iBAAiBvE,QAAQwE,YAAY,CAACC,GAAG,CAAC,GAAG9D,UAAU,QAAQ,EAAEyC,WAAW;gBAClF,MAAMsB,aAAa1E,QAAQiB,MAAM,CAACsD,eAAe;gBACjD,MAAMvE,QAAQ0D,WAAW,CAAC;oBACxBxD;oBACAS,WAAW4D;oBACX1D,OAAOvB,GAAGoF,WAAWpC,SAAS,EAAEvB,YAAYhB,EAAE;gBAChD;YACF;QACF;QAEA,4MAA4M;QAC5M,MAAM4E,sBAAuD,CAAC;QAE9D,KAAK,MAAM,CAACvB,WAAWwB,UAAU,IAAI9C,OAAOI,OAAO,CAACN,gBAAiB;YACnE,MAAM2C,iBAAiBvE,QAAQwE,YAAY,CAACC,GAAG,CAAC,GAAG9D,UAAU,QAAQ,EAAEyC,WAAW;YAClFiB,iBAAiB,CAACjB,UAAU,GAAG,MAAMpD,QAAQmB,MAAM,CAAC;gBAClDjB;gBACAS,WAAW4D;gBACXjD,QAAQsD,UAAUC,GAAG,CAAC,CAAC,EAAE3D,GAAG,EAAE,GAAKA;YACrC;YAEAmD,iBAAiB,CAACjB,UAAU,CAACjB,OAAO,CAAC,CAACjB,KAAK4D;gBACzCF,SAAS,CAACE,EAAE,CAAC5D,GAAG,GAAGA;gBACnB,IACE,OAAOA,IAAI6D,KAAK,KAAK,YACpB,CAAA,OAAO7D,IAAInB,EAAE,KAAK,YAAY,OAAOmB,IAAInB,EAAE,KAAK,QAAO,GACxD;oBACA4E,mBAAmB,CAACzD,IAAI6D,KAAK,CAAC,GAAG7D,IAAInB,EAAE;gBACzC;YACF;YAEA,MAAMiF,sBAAgC,EAAE;YAExC,MAAMC,0BAA0BL,UAAUM,MAAM,CAAC,CAACC,KAAK9B,UAAUyB;gBAC/D,IAAIhD,OAAOI,OAAO,CAACmB,SAASrB,OAAO,EAAEC,MAAM,GAAG,GAAG;oBAC/CH,OAAOI,OAAO,CAACmB,SAASrB,OAAO,EAAEG,OAAO,CAAC,CAAC,CAACiD,aAAaC,gBAAgB;wBACtE,IAAIvD,OAAOC,IAAI,CAACsD,iBAAiBpD,MAAM,GAAG,GAAG;4BAC3CoD,gBAAgB/C,SAAS,GAAGe,SAASnC,GAAG,CAACnB,EAAE;4BAC3CsF,gBAAgB9C,OAAO,GAAG6C;4BAC1BD,IAAI3C,IAAI,CAAC6C;4BACTL,oBAAoBxC,IAAI,CAACsC;wBAC3B;oBACF;gBACF;gBAEA,OAAOK;YACT,GAAG,EAAE;YAEL,IAAIF,wBAAwBhD,MAAM,GAAG,GAAG;gBACtC,MAAMjC,QAAQmB,MAAM,CAAC;oBACnBjB;oBACAS,WAAW,GAAG4D,iBAAiBvE,QAAQwD,aAAa,EAAE;oBACtDlC,QAAQ2D;gBACV;YACF;YAEA,MAAMpF,aAAa;gBACjBG;gBACAsF,QAAQV,UAAUC,GAAG,CAAC,CAAC,EAAES,MAAM,EAAE,GAAKA;gBACtCpF;gBACAqF,YAAYlB,iBAAiB,CAACjB,UAAU;gBACxCoC,SAASb;YACX;QACF;QAEA,qCAAqC;QACrC,4BAA4B;QAC5B,qCAAqC;QAErC,IAAIpE,cAAc,UAAU;YAC1B,KAAK,MAAMkF,kBAAkB3D,OAAOC,IAAI,CAACjB,YAAYwE,MAAM,EAAG;gBAC5D,MAAM3F,wBAAwB;oBAC5BK;oBACAE;oBACA6D,UAAUhD,YAAYhB,EAAE;oBACxBY,WAAW8E;gBACb;YACF;QACF;QAEA,MAAM5F,aAAa;YACjBG;YACAsF,QAAQ;gBAACxE,YAAYwE,MAAM;aAAC;YAC5BpF;YACAqF,YAAY;gBAACxE;aAAY;YACzByE,SAASb;QACX;QAEA,qCAAqC;QACrC,yBAAyB;QACzB,qCAAqC;QAErC,KAAK,MAAM,CAAC1B,iBAAiByC,UAAU,IAAI5D,OAAOI,OAAO,CAACL,iBAAkB;YAC1E,MAAM8D,cAAc3F,QAAQiB,MAAM,CAACgC,gBAAgB;YACnD,IAAI1C,cAAc,UAAU;gBAC1B,MAAMP,QAAQ0D,WAAW,CAAC;oBACxBxD;oBACAS,WAAWsC;oBACXpC,OAAOvB,GAAGqG,YAAYhD,MAAM,EAAE5B,YAAYhB,EAAE;gBAC9C;YACF;YAEA,IAAI+B,OAAOC,IAAI,CAAC4C,qBAAqB1C,MAAM,GAAG,GAAG;gBAC/CyD,UAAUvD,OAAO,CAAC,CAACjB;oBACjB,IAAIA,IAAIyB,MAAM,IAAIgC,qBAAqB;wBACrCzD,IAAIyB,MAAM,GAAGgC,mBAAmB,CAACzD,IAAIyB,MAAM,CAAC;oBAC9C;gBACF;YACF;YAEA,IAAI+C,UAAUzD,MAAM,EAAE;gBACpB,MAAMjC,QAAQmB,MAAM,CAAC;oBACnBjB;oBACAS,WAAWsC;oBACX3B,QAAQoE;gBACV;YACF;QACF;IAEA,qCAAqC;IACrC,iBAAiB;IACjB,qCAAqC;IACvC,EAAE,OAAOE,OAAO;QACd,IAAIA,MAAMC,IAAI,KAAK,SAAS;YAC1B,IAAIC,YAA2B;YAC/B,8GAA8G;YAC9G,IAAI9F,QAAQ+F,gBAAgB,EAAE,CAACpF,UAAU,EAAE;gBACzC,IAAIX,QAAQ+F,gBAAgB,CAACpF,UAAU,EAAE,CAACiF,MAAMI,UAAU,CAAC,EAAE;oBAC3DF,YAAY9F,QAAQ+F,gBAAgB,CAACpF,UAAU,EAAE,CAACiF,MAAMI,UAAU,CAAC;gBACrE,OAAO;oBACL,MAAMC,cAAc,GAAGtF,UAAU,CAAC,CAAC;oBAEnC,IAAIiF,MAAMI,UAAU,CAACE,QAAQ,CAACD,cAAc;wBAC1C,MAAME,qBAAqBP,MAAMI,UAAU,CAACI,OAAO,CAACH,aAAa;wBAEjE,IAAIE,sBAAsBnG,QAAQ+F,gBAAgB,CAACpF,UAAU,EAAE,CAACwF,mBAAmB,EAAE;4BACnFL,YAAY9F,QAAQ+F,gBAAgB,CAACpF,UAAU,CAACwF,mBAAmB;wBACrE;oBACF;gBACF;YACF;YAEA,IAAI,CAACL,WAAW;gBACd,+EAA+E;gBAC/E,MAAMO,SAAST,MAAMS,MAAM;gBAC3B,MAAMC,QAAQ;gBACd,MAAMC,QAAQF,OAAOE,KAAK,CAACD;gBAE3B,IAAIC,OAAO;oBACT,MAAMC,MAAMD,KAAK,CAAC,EAAE;oBAEpBT,YAAYU;gBACd;YACF;YAEA,MAAM,IAAIjH,gBACR;gBACEQ;gBACA0G,QAAQ;oBACN;wBACEC,SAASjG,KAAKkG,IAAIlG,IAAIkG,CAAC,CAAC,6BAA6B;wBACrDnG,MAAMsF;oBACR;iBACD;gBACDrF;YACF,GACAA,KAAKkG;QAET,OAAO;YACL,MAAMf;QACR;IACF;IAEA,IAAIxF,iBAAiB,UAAU;QAC7B,OAAO;YAAEL,IAAIgB,YAAYhB,EAAE;QAAC;IAC9B;IAEA,IAAIK,cAAc;QAChB,OAAOH;IACT;IAEA,qCAAqC;IACrC,6BAA6B;IAC7B,qCAAqC;IAErC,MAAM2G,eAAepH,kBAAkB;QACrCQ;QACA6G,OAAO;QACP1G;QACAE,WAAW;QACXK;QACAC;IACF;IAEAiG,aAAa/F,KAAK,GAAGvB,GAAGU,QAAQiB,MAAM,CAACN,UAAU,CAACZ,EAAE,EAAEgB,YAAYhB,EAAE;IAEpE,MAAM+G,MAAM,MAAM5G,GAAG6G,KAAK,CAACpG,UAAU,CAACqG,SAAS,CAACJ;IAEhD,qCAAqC;IACrC,iBAAiB;IACjB,qCAAqC;IAErC,MAAMK,SAASxH,UAAa;QAC1BO;QACAkH,QAAQlH,QAAQmH,OAAO,CAACD,MAAM;QAC9BjH,MAAM6G;QACN3G;QACAE,WAAW;QACXM;IACF;IAEA,OAAOsG;AACT,EAAC"}