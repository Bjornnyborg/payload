{"version":3,"file":"index.js","names":["htmlStartTagReg","htmlTagWithNameReg","htmlTagReg","htmlImgTagReg","htmlVideoTagReg","HtmlDiff","config","leastCommonLength","Infinity","matchedBlockList","newTokens","oldTokens","operationList","sideBySideContents","unifiedContent","constructor","oldHtml","newHtml","classNames","createBlock","createInline","deleteBlock","deleteInline","greedyBoundary","greedyMatch","minMatchedSize","trim","equalSequence","content","replace","match","name","tagNameLength","length","slice","tokenize","getMatchedBlockList","getOperationList","computeBestMatchedBlock","oldStart","oldEnd","newStart","newEnd","bestMatchedBlock","i","len","Math","min","ret","slideBestMatchedBlock","size","j","computeMatchedBlockList","matchBlock","push","dressUpBlockTag","type","token","dressUpDiffContent","tokens","tokensLength","result","textStartIndex","isMatchElement","includes","isMatchExplicitlyDisabled","isHtmlTag","dressUpText","newToken","dressupMatchEnabledHtmlTag","dressUpInlineTag","tagName","groups","matchType","text","join","n1","n2","start","end","e1","e2","commonLength","floor","unshift","walkIndexOld","walkIndexNew","matchedBlock","isOldStartIndexMatched","isNewStartIndexMatched","operationBase","Object","assign","maxIndexOld","maxIndexNew","tailOperationBase","isOldFinished","isNewFinished","addA","addB","maxSize","continuousSize","html","getSideBySideContents","undefined","forEach","operation","deletedTokens","equalTokens","equalString","startTagMatch","console","error","String","getUnifiedContent","olds","news","createdTokens","createIndex","deleteIndex","deletedToken","matchTagResultD","some","item","splice","isTagInNewFind","tempCreateIndex","createdToken","matchTagResultC","isEnd"],"sources":["../../../../src/field/Diff/htmlDiff/index.ts"],"sourcesContent":["// Taken and modified from https://github.com/Arman19941113/html-diff/blob/master/packages/html-diff/src/index.ts\n\ninterface MatchedBlock {\n  newEnd: number\n  newStart: number\n  oldEnd: number\n  oldStart: number\n  size: number\n}\n\ninterface Operation {\n  /**\n   * Index of entry in tokenized token list\n   */\n  newEnd: number\n  newStart: number\n  oldEnd: number\n  oldStart: number\n  type: 'create' | 'delete' | 'equal' | 'replace'\n}\n\ntype BaseOpType = 'create' | 'delete'\n\ninterface HtmlDiffConfig {\n  classNames: {\n    createBlock: string\n    createInline: string\n    deleteBlock: string\n    deleteInline: string\n  }\n  greedyBoundary: number\n  greedyMatch: boolean\n  minMatchedSize: number\n}\n\nexport interface HtmlDiffOptions {\n  /**\n   * The classNames for wrapper DOM.\n   * Use this to configure your own styles without importing the built-in CSS file\n   */\n  classNames?: Partial<{\n    createBlock?: string\n    createInline?: string\n    deleteBlock?: string\n    deleteInline?: string\n  }>\n  /**\n   * @defaultValue 1000\n   */\n  greedyBoundary?: number\n  /**\n   * When greedyMatch is enabled, if the length of the sub-tokens exceeds greedyBoundary,\n   * we will use the matched sub-tokens that are sufficiently good, even if they are not optimal, to enhance performance.\n   * @defaultValue true\n   */\n  greedyMatch?: boolean\n  /**\n   * Determine the minimum threshold for calculating common sub-tokens.\n   * You may adjust it to a value larger than 2, but not lower, due to the potential inclusion of HTML tags in the count.\n   * @defaultValue 2\n   */\n  minMatchedSize?: number\n}\n\n// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\nconst htmlStartTagReg = /^<(?<name>[^\\s/>]+)[^>]*>$/\n// eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\nconst htmlTagWithNameReg = /^<(?<isEnd>\\/)?(?<name>[^\\s>]+)[^>]*>$/\n\nconst htmlTagReg = /^<[^>]+>/\nconst htmlImgTagReg = /^<img[^>]*>$/\nconst htmlVideoTagReg = /^<video[^>]*>.*?<\\/video>$/ms\n\nexport class HtmlDiff {\n  private readonly config: HtmlDiffConfig\n  private leastCommonLength: number = Infinity\n  private readonly matchedBlockList: MatchedBlock[] = []\n  private readonly newTokens: string[] = []\n  private readonly oldTokens: string[] = []\n  private readonly operationList: Operation[] = []\n  private sideBySideContents?: [string, string]\n  private unifiedContent?: string\n\n  constructor(\n    oldHtml: string,\n    newHtml: string,\n    {\n      classNames = {\n        createBlock: 'html-diff-create-block-wrapper',\n        createInline: 'html-diff-create-inline-wrapper',\n        deleteBlock: 'html-diff-delete-block-wrapper',\n        deleteInline: 'html-diff-delete-inline-wrapper',\n      },\n      greedyBoundary = 1000,\n      greedyMatch = true,\n      minMatchedSize = 2,\n    }: HtmlDiffOptions = {},\n  ) {\n    // init config\n    this.config = {\n      classNames: {\n        createBlock: 'html-diff-create-block-wrapper',\n        createInline: 'html-diff-create-inline-wrapper',\n        deleteBlock: 'html-diff-delete-block-wrapper',\n        deleteInline: 'html-diff-delete-inline-wrapper',\n        ...classNames,\n      },\n      greedyBoundary,\n      greedyMatch,\n      minMatchedSize,\n    }\n    // white space is junk\n    oldHtml = oldHtml.trim()\n    newHtml = newHtml.trim()\n\n    // no need to diff\n    if (oldHtml === newHtml) {\n      this.unifiedContent = oldHtml\n      let equalSequence = 0\n      // eslint-disable-next-line regexp/no-super-linear-backtracking, regexp/optimal-quantifier-concatenation\n      const content = oldHtml.replace(/<([^\\s/>]+)[^>]*>/g, (match: string, name: string) => {\n        const tagNameLength = name.length + 1\n        return `${match.slice(0, tagNameLength)} data-seq=\"${++equalSequence}\"${match.slice(tagNameLength)}`\n      })\n      this.sideBySideContents = [content, content]\n      return\n    }\n\n    // step1: split HTML to tokens(atomic tokens)\n    this.oldTokens = this.tokenize(oldHtml)\n    this.newTokens = this.tokenize(newHtml)\n    // step2: find matched blocks\n    this.matchedBlockList = this.getMatchedBlockList()\n\n    // step3: generate operation list\n    this.operationList = this.getOperationList()\n  }\n\n  // Find the longest matched block between tokens\n  private computeBestMatchedBlock(\n    oldStart: number,\n    oldEnd: number,\n    newStart: number,\n    newEnd: number,\n  ): MatchedBlock | null {\n    let bestMatchedBlock = null\n    for (let i = oldStart; i < oldEnd; i++) {\n      const len = Math.min(oldEnd - i, newEnd - newStart)\n      const ret = this.slideBestMatchedBlock(i, newStart, len)\n      if (ret && (!bestMatchedBlock || ret.size > bestMatchedBlock.size)) {\n        bestMatchedBlock = ret\n        if (ret.size > this.leastCommonLength) {\n          return bestMatchedBlock\n        }\n      }\n    }\n    for (let j = newStart; j < newEnd; j++) {\n      const len = Math.min(oldEnd - oldStart, newEnd - j)\n      const ret = this.slideBestMatchedBlock(oldStart, j, len)\n      if (ret && (!bestMatchedBlock || ret.size > bestMatchedBlock.size)) {\n        bestMatchedBlock = ret\n        if (ret.size > this.leastCommonLength) {\n          return bestMatchedBlock\n        }\n      }\n    }\n    return bestMatchedBlock\n  }\n\n  private computeMatchedBlockList(\n    oldStart: number,\n    oldEnd: number,\n    newStart: number,\n    newEnd: number,\n    matchedBlockList: MatchedBlock[] = [],\n  ): MatchedBlock[] {\n    const matchBlock = this.computeBestMatchedBlock(oldStart, oldEnd, newStart, newEnd)\n\n    if (!matchBlock) {\n      return []\n    }\n\n    if (oldStart < matchBlock.oldStart && newStart < matchBlock.newStart) {\n      this.computeMatchedBlockList(\n        oldStart,\n        matchBlock.oldStart,\n        newStart,\n        matchBlock.newStart,\n        matchedBlockList,\n      )\n    }\n    matchedBlockList.push(matchBlock)\n    if (oldEnd > matchBlock.oldEnd && newEnd > matchBlock.newEnd) {\n      this.computeMatchedBlockList(\n        matchBlock.oldEnd,\n        oldEnd,\n        matchBlock.newEnd,\n        newEnd,\n        matchedBlockList,\n      )\n    }\n    return matchedBlockList\n  }\n\n  private dressUpBlockTag(type: BaseOpType, token: string): string {\n    if (type === 'create') {\n      return `<div class=\"${this.config.classNames.createBlock}\">${token}</div>`\n    }\n    if (type === 'delete') {\n      return `<div class=\"${this.config.classNames.deleteBlock}\">${token}</div>`\n    }\n    return ''\n  }\n\n  private dressUpDiffContent(type: BaseOpType, tokens: string[]): string {\n    const tokensLength = tokens.length\n    if (!tokensLength) {\n      return ''\n    }\n\n    let result = ''\n    let textStartIndex = 0\n    let i = -1\n    for (const token of tokens) {\n      i++\n\n      // If this is true, this HTML should be diffed as well - not just its children\n      const isMatchElement = token.includes('data-enable-match=\"true\"')\n      const isMatchExplicitlyDisabled = token.includes('data-enable-match=\"false\"')\n      const isHtmlTag = !!token.match(htmlTagReg)?.length\n\n      if (isMatchExplicitlyDisabled) {\n        textStartIndex = i + 1\n        result += token\n      }\n      // this token is html tag\n      else if (!isMatchElement && isHtmlTag) {\n        // handle text tokens before\n        if (i > textStartIndex) {\n          result += this.dressUpText(type, tokens.slice(textStartIndex, i))\n        }\n        // handle this tag\n        textStartIndex = i + 1\n        if (token.match(htmlVideoTagReg)) {\n          result += this.dressUpBlockTag(type, token)\n        } /* else if ([htmlImgTagReg].some((item) => token.match(item))) {\n          result += this.dressUpInlineTag(type, token)\n        }*/ else {\n          result += token\n        }\n      } else if (isMatchElement && isHtmlTag) {\n        // handle text tokens before\n        if (i > textStartIndex) {\n          result += this.dressUpText(type, tokens.slice(textStartIndex, i))\n        }\n\n        // handle this tag\n        textStartIndex = i + 1\n        // Add data-match-type to the tag that can be styled\n        const newToken = this.dressupMatchEnabledHtmlTag(type, token)\n\n        result += newToken\n      }\n    }\n    if (textStartIndex < tokensLength) {\n      result += this.dressUpText(type, tokens.slice(textStartIndex))\n    }\n    return result\n  }\n\n  private dressUpInlineTag(type: BaseOpType, token: string): string {\n    if (type === 'create') {\n      return `<span class=\"${this.config.classNames.createInline}\">${token}</span>`\n    }\n    if (type === 'delete') {\n      return `<span class=\"${this.config.classNames.deleteInline}\">${token}</span>`\n    }\n    return ''\n  }\n\n  private dressupMatchEnabledHtmlTag(type: BaseOpType, token: string): string {\n    // token is a single html tag, e.g. <a data-enable-match=\"true\" href=\"https://2\" rel=undefined target=undefined>\n    // add data-match-type to the tag\n    const tagName = token.match(htmlStartTagReg)?.groups?.name\n    if (!tagName) {\n      return token\n    }\n    const tagNameLength = tagName.length + 1\n    const matchType = type === 'create' ? 'create' : 'delete'\n    return `${token.slice(0, tagNameLength)} data-match-type=\"${matchType}\"${token.slice(\n      tagNameLength,\n      token.length,\n    )}`\n  }\n\n  private dressUpText(type: BaseOpType, tokens: string[]): string {\n    const text = tokens.join('')\n    if (!text.trim()) {\n      return ''\n    }\n    if (type === 'create') {\n      return `<span data-match-type=\"create\">${text}</span>`\n    }\n    if (type === 'delete') {\n      return `<span data-match-type=\"delete\">${text}</span>`\n    }\n    return ''\n  }\n\n  /**\n   * Generates a list of token entries that are matched between the old and new HTML. This list will not\n   * include token ranges that differ.\n   */\n  private getMatchedBlockList(): MatchedBlock[] {\n    const n1 = this.oldTokens.length\n    const n2 = this.newTokens.length\n\n    // 1. sync from start\n    let start: MatchedBlock | null = null\n    let i = 0\n    while (i < n1 && i < n2 && this.oldTokens[i] === this.newTokens[i]) {\n      i++\n    }\n    if (i >= this.config.minMatchedSize) {\n      start = {\n        newEnd: i,\n        newStart: 0,\n        oldEnd: i,\n        oldStart: 0,\n        size: i,\n      }\n    }\n\n    // 2. sync from end\n    let end: MatchedBlock | null = null\n    let e1 = n1 - 1\n    let e2 = n2 - 1\n    while (i <= e1 && i <= e2 && this.oldTokens[e1] === this.newTokens[e2]) {\n      e1--\n      e2--\n    }\n    const size = n1 - 1 - e1\n    if (size >= this.config.minMatchedSize) {\n      end = {\n        newEnd: n2,\n        newStart: e2 + 1,\n        oldEnd: n1,\n        oldStart: e1 + 1,\n        size,\n      }\n    }\n\n    // 3. handle rest\n    const oldStart = start ? i : 0\n    const oldEnd = end ? e1 + 1 : n1\n    const newStart = start ? i : 0\n    const newEnd = end ? e2 + 1 : n2\n    // optimize for large tokens\n    if (this.config.greedyMatch) {\n      const commonLength = Math.min(oldEnd - oldStart, newEnd - newStart)\n      if (commonLength > this.config.greedyBoundary) {\n        this.leastCommonLength = Math.floor(commonLength / 3)\n      }\n    }\n    const ret = this.computeMatchedBlockList(oldStart, oldEnd, newStart, newEnd)\n    if (start) {\n      ret.unshift(start)\n    }\n    if (end) {\n      ret.push(end)\n    }\n\n    return ret\n  }\n\n  // Generate operation list by matchedBlockList\n  private getOperationList(): Operation[] {\n    const operationList: Operation[] = []\n    let walkIndexOld = 0\n    let walkIndexNew = 0\n    for (const matchedBlock of this.matchedBlockList) {\n      const isOldStartIndexMatched = walkIndexOld === matchedBlock.oldStart\n      const isNewStartIndexMatched = walkIndexNew === matchedBlock.newStart\n      const operationBase = {\n        newEnd: matchedBlock.newStart,\n        newStart: walkIndexNew,\n        oldEnd: matchedBlock.oldStart,\n        oldStart: walkIndexOld,\n      }\n      if (!isOldStartIndexMatched && !isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'replace' as const }))\n      } else if (isOldStartIndexMatched && !isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'create' as const }))\n      } else if (!isOldStartIndexMatched && isNewStartIndexMatched) {\n        operationList.push(Object.assign(operationBase, { type: 'delete' as const }))\n      }\n\n      operationList.push({\n        type: 'equal',\n        newEnd: matchedBlock.newEnd,\n        newStart: matchedBlock.newStart,\n        oldEnd: matchedBlock.oldEnd,\n        oldStart: matchedBlock.oldStart,\n      })\n      walkIndexOld = matchedBlock.oldEnd\n      walkIndexNew = matchedBlock.newEnd\n    }\n    // handle the tail content\n    const maxIndexOld = this.oldTokens.length\n    const maxIndexNew = this.newTokens.length\n    const tailOperationBase = {\n      newEnd: maxIndexNew,\n      newStart: walkIndexNew,\n      oldEnd: maxIndexOld,\n      oldStart: walkIndexOld,\n    }\n    const isOldFinished = walkIndexOld === maxIndexOld\n    const isNewFinished = walkIndexNew === maxIndexNew\n    if (!isOldFinished && !isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'replace' as const }))\n    } else if (isOldFinished && !isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'create' as const }))\n    } else if (!isOldFinished && isNewFinished) {\n      operationList.push(Object.assign(tailOperationBase, { type: 'delete' as const }))\n    }\n    return operationList\n  }\n\n  private slideBestMatchedBlock(addA: number, addB: number, len: number): MatchedBlock | null {\n    let maxSize = 0\n    let bestMatchedBlock: MatchedBlock | null = null\n\n    let continuousSize = 0\n    for (let i = 0; i < len; i++) {\n      if (this.oldTokens[addA + i] === this.newTokens[addB + i]) {\n        continuousSize++\n      } else {\n        continuousSize = 0\n      }\n      if (continuousSize > maxSize) {\n        maxSize = continuousSize\n        bestMatchedBlock = {\n          newEnd: addB + i + 1,\n          newStart: addB + i - continuousSize + 1,\n          oldEnd: addA + i + 1,\n          oldStart: addA + i - continuousSize + 1,\n          size: continuousSize,\n        }\n      }\n    }\n\n    return maxSize >= this.config.minMatchedSize ? bestMatchedBlock : null\n  }\n\n  /**\n   * convert HTML to tokens\n   * @example\n   * tokenize(\"<a> Hello World </a>\")\n   * [\"<a>\",\" \", \"Hello\", \" \", \"World\", \" \", \"</a>\"]\n   */\n  private tokenize(html: string): string[] {\n    // atomic token: html tag、continuous numbers or letters、blank spaces、other symbol\n    return (\n      html.match(\n        /<picture[^>]*>.*?<\\/picture>|<video[^>]*>.*?<\\/video>|<[^>]+>|\\w+\\b|\\s+|[^<>\\w]/gs,\n      ) || []\n    )\n  }\n\n  public getSideBySideContents(): string[] {\n    if (this.sideBySideContents !== undefined) {\n      return this.sideBySideContents\n    }\n\n    let oldHtml = ''\n    let newHtml = ''\n    let equalSequence = 0\n    this.operationList.forEach((operation) => {\n      switch (operation.type) {\n        case 'create': {\n          newHtml += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        case 'delete': {\n          const deletedTokens = this.oldTokens.slice(operation.oldStart, operation.oldEnd)\n          oldHtml += this.dressUpDiffContent('delete', deletedTokens)\n          break\n        }\n        case 'equal': {\n          const equalTokens = this.newTokens.slice(operation.newStart, operation.newEnd)\n          let equalString = ''\n          for (const token of equalTokens) {\n            // find start tags and add data-seq to enable sync scroll\n            const startTagMatch = token.match(htmlStartTagReg)\n            if (startTagMatch) {\n              equalSequence += 1\n              const tagNameLength = (startTagMatch?.groups?.name?.length ?? 0) + 1\n              equalString += `${token.slice(0, tagNameLength)} data-seq=\"${equalSequence}\"${token.slice(tagNameLength)}`\n            } else {\n              equalString += token\n            }\n          }\n          oldHtml += equalString\n          newHtml += equalString\n          break\n        }\n\n        case 'replace': {\n          oldHtml += this.dressUpDiffContent(\n            'delete',\n            this.oldTokens.slice(operation.oldStart, operation.oldEnd),\n          )\n          newHtml += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        default: {\n          console.error('Richtext diff error - invalid operation: ' + String(operation.type))\n        }\n      }\n    })\n\n    const result: [string, string] = [oldHtml, newHtml]\n    this.sideBySideContents = result\n    return result\n  }\n\n  public getUnifiedContent(): string {\n    if (this.unifiedContent !== undefined) {\n      return this.unifiedContent\n    }\n\n    let result = ''\n    this.operationList.forEach((operation) => {\n      switch (operation.type) {\n        case 'create': {\n          result += this.dressUpDiffContent(\n            'create',\n            this.newTokens.slice(operation.newStart, operation.newEnd),\n          )\n          break\n        }\n\n        case 'delete': {\n          result += this.dressUpDiffContent(\n            'delete',\n            this.oldTokens.slice(operation.oldStart, operation.oldEnd),\n          )\n          break\n        }\n\n        case 'equal': {\n          for (const token of this.newTokens.slice(operation.newStart, operation.newEnd)) {\n            result += token\n          }\n          break\n        }\n\n        case 'replace': {\n          // handle specially tag replace\n          const olds = this.oldTokens.slice(operation.oldStart, operation.oldEnd)\n          const news = this.newTokens.slice(operation.newStart, operation.newEnd)\n          if (\n            olds.length === 1 &&\n            news.length === 1 &&\n            olds[0]?.match(htmlTagReg) &&\n            news[0]?.match(htmlTagReg)\n          ) {\n            result += news[0]\n            break\n          }\n\n          const deletedTokens: string[] = []\n          const createdTokens: string[] = []\n          let createIndex = operation.newStart\n          for (\n            let deleteIndex = operation.oldStart;\n            deleteIndex < operation.oldEnd;\n            deleteIndex++\n          ) {\n            const deletedToken = this.oldTokens[deleteIndex]\n\n            if (!deletedToken) {\n              continue\n            }\n\n            const matchTagResultD = deletedToken?.match(htmlTagWithNameReg)\n            if (matchTagResultD) {\n              // handle replaced tag token\n\n              // skip special tag\n              if ([htmlImgTagReg, htmlVideoTagReg].some((item) => deletedToken?.match(item))) {\n                deletedTokens.push(deletedToken)\n                continue\n              }\n\n              // handle normal tag\n              result += this.dressUpDiffContent('delete', deletedTokens)\n              deletedTokens.splice(0)\n              let isTagInNewFind = false\n              for (\n                let tempCreateIndex = createIndex;\n                tempCreateIndex < operation.newEnd;\n                tempCreateIndex++\n              ) {\n                const createdToken = this.newTokens[tempCreateIndex]\n                if (!createdToken) {\n                  continue\n                }\n                const matchTagResultC = createdToken?.match(htmlTagWithNameReg)\n                if (\n                  matchTagResultC &&\n                  matchTagResultC.groups?.name === matchTagResultD.groups?.name &&\n                  matchTagResultC.groups?.isEnd === matchTagResultD.groups?.isEnd\n                ) {\n                  // find first matched tag, but not maybe the expected tag(to optimize)\n                  isTagInNewFind = true\n                  result += this.dressUpDiffContent('create', createdTokens)\n                  result += createdToken\n                  createdTokens.splice(0)\n                  createIndex = tempCreateIndex + 1\n                  break\n                } else {\n                  createdTokens.push(createdToken)\n                }\n              }\n              if (!isTagInNewFind) {\n                result += deletedToken\n                createdTokens.splice(0)\n              }\n            } else {\n              // token is not a tag\n              deletedTokens.push(deletedToken)\n            }\n          }\n          if (createIndex < operation.newEnd) {\n            createdTokens.push(...this.newTokens.slice(createIndex, operation.newEnd))\n          }\n          result += this.dressUpDiffContent('delete', deletedTokens)\n          result += this.dressUpDiffContent('create', createdTokens)\n          break\n        }\n\n        default: {\n          console.error('Richtext diff error - invalid operation: ' + String(operation.type))\n        }\n      }\n    })\n    this.unifiedContent = result\n    return result\n  }\n}\n"],"mappings":"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","ignoreList":[]}