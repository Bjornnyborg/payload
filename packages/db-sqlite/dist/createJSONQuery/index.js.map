{"version":3,"sources":["../../src/createJSONQuery/index.ts"],"sourcesContent":["import type { CreateJSONQueryArgs } from '@payloadcms/drizzle/types'\n\ntype FromArrayArgs = {\n  isRoot?: true\n  operator: string\n  pathSegments: string[]\n  table: string\n  treatAsArray?: string[]\n  value: boolean | number | string\n}\n\nconst fromArray = ({\n  isRoot,\n  operator,\n  pathSegments,\n  table,\n  treatAsArray,\n  value,\n}: FromArrayArgs) => {\n  const newPathSegments = pathSegments.slice(1)\n  const alias = `${pathSegments[isRoot ? 0 : 1]}_alias_${newPathSegments.length}`\n\n  return `EXISTS (\n    SELECT 1\n    FROM json_each(${table}.${pathSegments[0]}) AS ${alias}\n    WHERE ${createJSONQuery({\n      operator,\n      pathSegments: newPathSegments,\n      table: alias,\n      treatAsArray,\n      value,\n    })}\n  )`\n}\n\ntype CreateConstraintArgs = {\n  alias?: string\n  operator: string\n  pathSegments: string[]\n  treatAsArray?: string[]\n  value: boolean | number | string\n}\n\nconst createConstraint = ({\n  alias,\n  operator,\n  pathSegments,\n  value,\n}: CreateConstraintArgs): string => {\n  const newAlias = `${pathSegments[0]}_alias_${pathSegments.length - 1}`\n  let formattedValue = value\n  let formattedOperator = operator\n  if (['contains', 'like'].includes(operator)) {\n    formattedOperator = 'like'\n    formattedValue = `%${value}%`\n  } else if (['not_like', 'notlike'].includes(operator)) {\n    formattedOperator = 'not like'\n    formattedValue = `%${value}%`\n  } else if (operator === 'equals') {\n    formattedOperator = '='\n  }\n\n  return `EXISTS (\n  SELECT 1\n  FROM json_each(${alias}.value -> '${pathSegments[0]}') AS ${newAlias}\n  WHERE COALESCE(${newAlias}.value ->> '${pathSegments[1]}', '') ${formattedOperator} '${formattedValue}'\n  )`\n}\n\nexport const createJSONQuery = ({\n  operator,\n  pathSegments,\n  table,\n  treatAsArray,\n  value,\n}: CreateJSONQueryArgs): string => {\n  if (treatAsArray?.includes(pathSegments[1]!) && table) {\n    return fromArray({\n      operator,\n      pathSegments,\n      table,\n      treatAsArray,\n      value,\n    })\n  }\n\n  return createConstraint({ alias: table, operator, pathSegments, treatAsArray, value })\n}\n"],"names":["fromArray","isRoot","operator","pathSegments","table","treatAsArray","value","newPathSegments","slice","alias","length","createJSONQuery","createConstraint","newAlias","formattedValue","formattedOperator","includes"],"mappings":"AAWA,MAAMA,YAAY,CAAC,EACjBC,MAAM,EACNC,QAAQ,EACRC,YAAY,EACZC,KAAK,EACLC,YAAY,EACZC,KAAK,EACS;IACd,MAAMC,kBAAkBJ,aAAaK,KAAK,CAAC;IAC3C,MAAMC,QAAQ,GAAGN,YAAY,CAACF,SAAS,IAAI,EAAE,CAAC,OAAO,EAAEM,gBAAgBG,MAAM,EAAE;IAE/E,OAAO,CAAC;;mBAES,EAAEN,MAAM,CAAC,EAAED,YAAY,CAAC,EAAE,CAAC,KAAK,EAAEM,MAAM;UACjD,EAAEE,gBAAgB;QACtBT;QACAC,cAAcI;QACdH,OAAOK;QACPJ;QACAC;IACF,GAAG;GACJ,CAAC;AACJ;AAUA,MAAMM,mBAAmB,CAAC,EACxBH,KAAK,EACLP,QAAQ,EACRC,YAAY,EACZG,KAAK,EACgB;IACrB,MAAMO,WAAW,GAAGV,YAAY,CAAC,EAAE,CAAC,OAAO,EAAEA,aAAaO,MAAM,GAAG,GAAG;IACtE,IAAII,iBAAiBR;IACrB,IAAIS,oBAAoBb;IACxB,IAAI;QAAC;QAAY;KAAO,CAACc,QAAQ,CAACd,WAAW;QAC3Ca,oBAAoB;QACpBD,iBAAiB,CAAC,CAAC,EAAER,MAAM,CAAC,CAAC;IAC/B,OAAO,IAAI;QAAC;QAAY;KAAU,CAACU,QAAQ,CAACd,WAAW;QACrDa,oBAAoB;QACpBD,iBAAiB,CAAC,CAAC,EAAER,MAAM,CAAC,CAAC;IAC/B,OAAO,IAAIJ,aAAa,UAAU;QAChCa,oBAAoB;IACtB;IAEA,OAAO,CAAC;;iBAEO,EAAEN,MAAM,WAAW,EAAEN,YAAY,CAAC,EAAE,CAAC,MAAM,EAAEU,SAAS;iBACtD,EAAEA,SAAS,YAAY,EAAEV,YAAY,CAAC,EAAE,CAAC,OAAO,EAAEY,kBAAkB,EAAE,EAAED,eAAe;GACrG,CAAC;AACJ;AAEA,OAAO,MAAMH,kBAAkB,CAAC,EAC9BT,QAAQ,EACRC,YAAY,EACZC,KAAK,EACLC,YAAY,EACZC,KAAK,EACe;IACpB,IAAID,cAAcW,SAASb,YAAY,CAAC,EAAE,KAAMC,OAAO;QACrD,OAAOJ,UAAU;YACfE;YACAC;YACAC;YACAC;YACAC;QACF;IACF;IAEA,OAAOM,iBAAiB;QAAEH,OAAOL;QAAOF;QAAUC;QAAcE;QAAcC;IAAM;AACtF,EAAC"}