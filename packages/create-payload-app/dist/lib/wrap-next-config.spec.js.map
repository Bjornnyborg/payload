{"version":3,"sources":["../../src/lib/wrap-next-config.spec.ts"],"sourcesContent":["import * as p from '@clack/prompts'\nimport { jest } from '@jest/globals'\n\nimport { parseAndModifyConfigContent, withPayloadStatement } from './wrap-next-config.js'\n\nconst tsConfigs = {\n  defaultNextConfig: `import type { NextConfig } from \"next\";\n\nconst nextConfig: NextConfig = {};\nexport default nextConfig;`,\n\n  nextConfigExportNamedDefault: `import type { NextConfig } from \"next\";\nconst nextConfig: NextConfig = {};\nconst wrapped = someFunc(asdf);\nexport { wrapped as default };\n`,\n  nextConfigWithFunc: `import type { NextConfig } from \"next\";\nconst nextConfig: NextConfig = {};\nexport default someFunc(nextConfig);\n`,\n  nextConfigWithFuncMultiline: `import type { NextConfig } from \"next\";\nconst nextConfig: NextConfig = {};\nexport default someFunc(\n  nextConfig\n);\n`,\n  nextConfigWithSpread: `import type { NextConfig } from \"next\";\nconst nextConfig: NextConfig = {\n  ...someConfig,\n};\nexport default nextConfig;\n`,\n}\n\nconst esmConfigs = {\n  defaultNextConfig: `/** @type {import('next').NextConfig} */\nconst nextConfig = {};\nexport default nextConfig;\n`,\n  nextConfigExportNamedDefault: `const nextConfig = {};\nconst wrapped = someFunc(asdf);\nexport { wrapped as default };\n`,\n  nextConfigWithFunc: `const nextConfig = {};\nexport default someFunc(nextConfig);\n`,\n  nextConfigWithFuncMultiline: `const nextConfig = {};;\nexport default someFunc(\n  nextConfig\n);\n`,\n  nextConfigWithSpread: `const nextConfig = {\n  ...someConfig,\n};\nexport default nextConfig;\n`,\n}\n\nconst cjsConfigs = {\n  anonConfig: `module.exports = {};`,\n  defaultNextConfig: `\n  /** @type {import('next').NextConfig} */\nconst nextConfig = {};\nmodule.exports = nextConfig;\n`,\n  nextConfigExportNamedDefault: `const nextConfig = {};\nconst wrapped = someFunc(asdf);\nmodule.exports = wrapped;\n`,\n  nextConfigWithFunc: `const nextConfig = {};\nmodule.exports = someFunc(nextConfig);\n`,\n  nextConfigWithFuncMultiline: `const nextConfig = {};\nmodule.exports = someFunc(\n  nextConfig\n);\n`,\n  nextConfigWithSpread: `const nextConfig = { ...someConfig };\nmodule.exports = nextConfig;\n`,\n}\n\ndescribe('parseAndInsertWithPayload', () => {\n  describe('ts', () => {\n    const configType = 'ts'\n    const importStatement = withPayloadStatement[configType]\n\n    it('should parse the default next config', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        tsConfigs.defaultNextConfig,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n\n    it('should parse the config with a function', async () => {\n      const { modifiedConfigContent: modifiedConfigContent2 } = await parseAndModifyConfigContent(\n        tsConfigs.nextConfigWithFunc,\n        configType,\n      )\n      expect(modifiedConfigContent2).toContain('withPayload(someFunc(nextConfig))')\n    })\n\n    it('should parse the config with a multi-lined function', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        tsConfigs.nextConfigWithFuncMultiline,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toMatch(/withPayload\\(someFunc\\(\\n {2}nextConfig\\n\\)\\)/)\n    })\n\n    it('should parse the config with a spread', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        tsConfigs.nextConfigWithSpread,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n  })\n  describe('esm', () => {\n    const configType = 'esm'\n    const importStatement = withPayloadStatement[configType]\n    it('should parse the default next config', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        esmConfigs.defaultNextConfig,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n    it('should parse the config with a function', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        esmConfigs.nextConfigWithFunc,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain('withPayload(someFunc(nextConfig))')\n    })\n\n    it('should parse the config with a multi-lined function', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        esmConfigs.nextConfigWithFuncMultiline,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toMatch(/withPayload\\(someFunc\\(\\n {2}nextConfig\\n\\)\\)/)\n    })\n\n    it('should parse the config with a spread', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        esmConfigs.nextConfigWithSpread,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n\n    // Unsupported: export { wrapped as default }\n    it('should give warning with a named export as default', async () => {\n      const warnLogSpy = jest.spyOn(p.log, 'warn').mockImplementation(() => {})\n\n      const { modifiedConfigContent, success } = await parseAndModifyConfigContent(\n        esmConfigs.nextConfigExportNamedDefault,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(importStatement)\n      expect(success).toBe(false)\n\n      expect(warnLogSpy).toHaveBeenCalledWith(\n        expect.stringContaining('Could not automatically wrap'),\n      )\n    })\n  })\n\n  describe('cjs', () => {\n    const configType = 'cjs'\n    const requireStatement = withPayloadStatement[configType]\n    it('should parse the default next config', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.defaultNextConfig,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(requireStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n    it('should parse anonymous default config', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.anonConfig,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(requireStatement)\n      expect(modifiedConfigContent).toContain('withPayload({})')\n    })\n    it('should parse the config with a function', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.nextConfigWithFunc,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain('withPayload(someFunc(nextConfig))')\n    })\n    it('should parse the config with a multi-lined function', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.nextConfigWithFuncMultiline,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(requireStatement)\n      expect(modifiedConfigContent).toMatch(/withPayload\\(someFunc\\(\\n {2}nextConfig\\n\\)\\)/)\n    })\n    it('should parse the config with a named export as default', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.nextConfigExportNamedDefault,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(requireStatement)\n      expect(modifiedConfigContent).toContain('withPayload(wrapped)')\n    })\n\n    it('should parse the config with a spread', async () => {\n      const { modifiedConfigContent } = await parseAndModifyConfigContent(\n        cjsConfigs.nextConfigWithSpread,\n        configType,\n      )\n      expect(modifiedConfigContent).toContain(requireStatement)\n      expect(modifiedConfigContent).toContain('withPayload(nextConfig)')\n    })\n  })\n})\n"],"names":["p","jest","parseAndModifyConfigContent","withPayloadStatement","tsConfigs","defaultNextConfig","nextConfigExportNamedDefault","nextConfigWithFunc","nextConfigWithFuncMultiline","nextConfigWithSpread","esmConfigs","cjsConfigs","anonConfig","describe","configType","importStatement","it","modifiedConfigContent","expect","toContain","modifiedConfigContent2","toMatch","warnLogSpy","spyOn","log","mockImplementation","success","toBe","toHaveBeenCalledWith","stringContaining","requireStatement"],"mappings":"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"}