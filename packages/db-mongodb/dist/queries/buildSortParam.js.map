{"version":3,"sources":["../../src/queries/buildSortParam.ts"],"sourcesContent":["import type { PipelineStage } from 'mongoose'\n\nimport {\n  APIError,\n  type FlattenedField,\n  getFieldByPath,\n  type SanitizedConfig,\n  type Sort,\n} from 'payload'\n\nimport type { MongooseAdapter } from '../index.js'\n\nimport { getCollection } from '../utilities/getEntity.js'\nimport { getLocalizedSortProperty } from './getLocalizedSortProperty.js'\n\ntype Args = {\n  adapter: MongooseAdapter\n  config: SanitizedConfig\n  fields: FlattenedField[]\n  locale?: string\n  parentIsLocalized?: boolean\n  sort: Sort\n  sortAggregation?: PipelineStage[]\n  timestamps: boolean\n  versions?: boolean\n}\n\nexport type SortArgs = {\n  direction: SortDirection\n  property: string\n}[]\n\nexport type SortDirection = 'asc' | 'desc'\n\nconst relationshipSort = ({\n  adapter,\n  fields,\n  locale,\n  path,\n  sort,\n  sortAggregation,\n  sortDirection,\n  versions,\n}: {\n  adapter: MongooseAdapter\n  fields: FlattenedField[]\n  locale?: string\n  path: string\n  sort: Record<string, string>\n  sortAggregation: PipelineStage[]\n  sortDirection: SortDirection\n  versions?: boolean\n}) => {\n  let currentFields = fields\n  const segments = path.split('.')\n  if (segments.length < 2) {\n    return false\n  }\n\n  for (const [i, segment] of segments.entries()) {\n    if (versions && i === 0 && segment === 'version') {\n      segments.shift()\n      continue\n    }\n\n    const field = currentFields.find((each) => each.name === segment)\n\n    if (!field) {\n      return false\n    }\n\n    if ('fields' in field) {\n      currentFields = field.flattenedFields\n    } else if (\n      (field.type === 'relationship' || field.type === 'upload') &&\n      i !== segments.length - 1\n    ) {\n      const relationshipPath = segments.slice(0, i + 1).join('.')\n      let sortFieldPath = segments.slice(i + 1, segments.length).join('.')\n      if (Array.isArray(field.relationTo)) {\n        throw new APIError('Not supported')\n      }\n\n      const foreignCollection = getCollection({ adapter, collectionSlug: field.relationTo })\n\n      const foreignFieldPath = getFieldByPath({\n        fields: foreignCollection.collectionConfig.flattenedFields,\n        path: sortFieldPath,\n      })\n\n      if (!foreignFieldPath) {\n        return false\n      }\n\n      if (foreignFieldPath.pathHasLocalized && locale) {\n        sortFieldPath = foreignFieldPath.localizedPath.replace('<locale>', locale)\n      }\n\n      if (\n        !sortAggregation.some((each) => {\n          return '$lookup' in each && each.$lookup.as === `__${path}`\n        })\n      ) {\n        sortAggregation.push({\n          $lookup: {\n            as: `__${path}`,\n            foreignField: '_id',\n            from: foreignCollection.Model.collection.name,\n            localField: relationshipPath,\n            pipeline: [\n              {\n                $project: {\n                  [sortFieldPath]: true,\n                },\n              },\n            ],\n          },\n        })\n\n        sort[`__${path}.${sortFieldPath}`] = sortDirection\n\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nexport const buildSortParam = ({\n  adapter,\n  config,\n  fields,\n  locale,\n  parentIsLocalized = false,\n  sort,\n  sortAggregation,\n  timestamps,\n  versions,\n}: Args): Record<string, string> => {\n  if (!sort) {\n    if (timestamps) {\n      sort = '-createdAt'\n    } else {\n      sort = '-id'\n    }\n  }\n\n  if (typeof sort === 'string') {\n    sort = [sort]\n  }\n\n  const sorting = sort.reduce<Record<string, string>>((acc, item) => {\n    let sortProperty: string\n    let sortDirection: SortDirection\n    if (item.indexOf('-') === 0) {\n      sortProperty = item.substring(1)\n      sortDirection = 'desc'\n    } else {\n      sortProperty = item\n      sortDirection = 'asc'\n    }\n    if (sortProperty === 'id') {\n      acc['_id'] = sortDirection\n      return acc\n    }\n\n    if (\n      sortAggregation &&\n      relationshipSort({\n        adapter,\n        fields,\n        locale,\n        path: sortProperty,\n        sort: acc,\n        sortAggregation,\n        sortDirection,\n        versions,\n      })\n    ) {\n      return acc\n    }\n\n    const localizedProperty = getLocalizedSortProperty({\n      config,\n      fields,\n      locale,\n      parentIsLocalized,\n      segments: sortProperty.split('.'),\n    })\n    acc[localizedProperty] = sortDirection\n\n    return acc\n  }, {})\n\n  return sorting\n}\n"],"names":["APIError","getFieldByPath","getCollection","getLocalizedSortProperty","relationshipSort","adapter","fields","locale","path","sort","sortAggregation","sortDirection","versions","currentFields","segments","split","length","i","segment","entries","shift","field","find","each","name","flattenedFields","type","relationshipPath","slice","join","sortFieldPath","Array","isArray","relationTo","foreignCollection","collectionSlug","foreignFieldPath","collectionConfig","pathHasLocalized","localizedPath","replace","some","$lookup","as","push","foreignField","from","Model","collection","localField","pipeline","$project","buildSortParam","config","parentIsLocalized","timestamps","sorting","reduce","acc","item","sortProperty","indexOf","substring","localizedProperty"],"mappings":"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"}